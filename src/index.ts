import { app, Tray, Menu, globalShortcut, clipboard, nativeImage, BrowserWindow, screen, ipcMain, dialog, shell, session } from 'electron';
import * as path from 'path';
import { callWhisperApi, callTextToSpeechApi } from './openai-api';
import { callDaemonQuickEdit } from './python-daemon-api';
import { config } from './config';
import { WebAudioRecorder } from './audio-recorder';
import { ClipboardHistory } from './clipboard-history';
import { AudioPlayer } from './audio-player';
import { PythonSpellCaster, pythonSpellCaster } from './python-spells';
import { ShortcutsManager } from './shortcuts-manager';
import { PythonDaemon } from './python-daemon';
import { PythonRunner } from './python-runner';
import { PythonSpell } from './python-spells';
import { UserDataManager } from './user-data-manager';
import * as fs from 'fs';

// This allows TypeScript to pick up the magic constants that are auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code.
// We don't have a window anymore, but we'll keep these for potential future use.
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const VISUALIZER_WINDOW_WEBPACK_ENTRY: string;
declare const VISUALIZER_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const PASTILLE_WINDOW_WEBPACK_ENTRY: string;
declare const PASTILLE_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const SETTINGS_WINDOW_WEBPACK_ENTRY: string;
declare const SETTINGS_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const SPELL_BOOK_WINDOW_WEBPACK_ENTRY: string;
declare const SPELL_BOOK_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

let tray: Tray | null = null;
let recorder: WebAudioRecorder | null = null;
let visualizerWindow: null = null;
let pastilleWindow: BrowserWindow | null = null;
let settingsWindow: BrowserWindow | null = null;
let spellBookWindow: BrowserWindow | null = null;
let clipboardHistory: ClipboardHistory | null = null;
let audioPlayer: AudioPlayer | null = null;
let shortcutsManager: ShortcutsManager | null = null;
let userDataManager: UserDataManager | null = null;
let spellCaster: PythonSpellCaster | null = null;

// Persistent env config path and helpers
const ENV_CONFIG_PATH = path.join(app.getPath('userData'), 'env_config.json');

interface EnvConfigFile { env: Record<string,string>; llm: string; llms?: string[]; }

function readEnvConfig(): EnvConfigFile {
  try {
    if (fs.existsSync(ENV_CONFIG_PATH)) {
      return JSON.parse(fs.readFileSync(ENV_CONFIG_PATH, 'utf-8')) as EnvConfigFile;
    }
  } catch {}
  return { env: {}, llm: '', llms: [] };
}

function writeEnvConfig(data: EnvConfigFile) {
  try {
    fs.mkdirSync(path.dirname(ENV_CONFIG_PATH), { recursive: true });
    fs.writeFileSync(ENV_CONFIG_PATH, JSON.stringify(data, null, 2), 'utf-8');
  } catch (err) {
    console.error('‚ùå Failed to persist env config', err);
  }
}

// Windows debugging setup
if (process.platform === 'win32') {
  // Always enable console for Windows debugging (both dev and production)
  try {
    const { exec } = require('child_process');
    
    // Allocate console window for debugging
    if (!app.isPackaged) {
      // Development: spawn a separate console window
      exec('start "MetaKeyAI Debug Console" cmd /k "echo MetaKeyAI Debug Console Started & echo Press Ctrl+C to close"', { detached: true });
    } else {
      // Production: try to allocate console to current process
      try {
        const kernel32 = require('ffi-napi').Library('kernel32', {
          'AllocConsole': ['bool', []],
          'FreeConsole': ['bool', []]
        });
        kernel32.AllocConsole();
        console.log('‚úÖ Console allocated for Windows debugging');
      } catch (ffiError) {
        // Fallback: create a debug window
        console.log('‚ö†Ô∏è FFI not available, using fallback debug method');
      }
    }
  } catch (error) {
    console.log('Could not allocate debug console:', error);
  }
}

// Enhanced logging for Windows
// Save original console methods first to prevent recursion
const originalConsoleLog = console.log;
const originalConsoleError = console.error;

class WindowsLogger {
  private logFile: string;
  private debugMode: boolean;
  
  constructor() {
    this.debugMode = process.platform === 'win32';
    
    const logDir = app.isPackaged ? 
      path.join(process.env.APPDATA || '', 'MetaKeyAI', 'logs') : 
      path.join(process.cwd(), 'logs');
    
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }
    
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    this.logFile = path.join(logDir, `metakeyai-${timestamp}.log`);
    
    // Use this.log, which now correctly uses originalConsoleLog
    this.log('üöÄ MetaKeyAI Debug Logger Started');
    this.log(`üìç Platform: ${process.platform} ${process.arch}`);
    this.log(`üì¶ Packaged: ${app.isPackaged}`);
    this.log(`üìÇ Log file: ${this.logFile}`);
    this.log(`üîß Node version: ${process.version}`);
    this.log(`‚ö° Electron version: ${process.versions.electron}`);
    this.log(`üè† App path: ${app.getAppPath()}`);
    this.log(`üíæ User data: ${app.getPath('userData')}`);
    
    if (process.platform === 'win32') {
      this.log(`ü™ü Windows version: ${require('os').release()}`);
      this.log(`üéØ Resources path: ${process.resourcesPath || 'N/A'}`);
    }
  }
  
  private writeToFile(logEntry: string) {
    try {
      fs.appendFileSync(this.logFile, logEntry);
    } catch (error) {
      originalConsoleError('Failed to write to log file:', error);
    }
  }

  log(message: string) {
    const timestamp = new Date().toISOString();
    const logEntry = `[${timestamp}] ${message}\n`;
    
    // Always log to console using original function
    originalConsoleLog(message);
    
    // Also log to file
    this.writeToFile(logEntry);
  }
  
  error(message: string, error?: any) {
    const errorMsg = error ? `${message}: ${error.message || error}` : message;
    const fullMessage = `‚ùå ERROR: ${errorMsg}`;

    const timestamp = new Date().toISOString();
    const logEntry = `[${timestamp}] ${fullMessage}\n`;
    
    // Log to original console
    originalConsoleError(fullMessage);
    
    // Also log to file
    this.writeToFile(logEntry);

    if (error?.stack) {
      const stackLogEntry = `[${timestamp}] üìç Stack: ${error.stack}\n`;
      originalConsoleError(`üìç Stack: ${error.stack}`);
      this.writeToFile(stackLogEntry);
    }
    
    // For Windows, also try to show a notification
    if (this.debugMode && app.isPackaged) {
      try {
        const { Notification } = require('electron');
        if (Notification.isSupported()) {
          new Notification({
            title: 'MetaKeyAI Error',
            body: errorMsg.substring(0, 100) + (errorMsg.length > 100 ? '...' : ''),
            urgency: 'critical'
          }).show();
        }
      } catch (notifError) {
        // Ignore notification errors
      }
    }
  }
  
  debug(message: string) {
    if (this.debugMode) {
      this.log(`üêõ DEBUG: ${message}`);
    }
  }
  
  getLogPath(): string {
    return this.logFile;
  }
  
  getLogDirectory(): string {
    return path.dirname(this.logFile);
  }
}

const logger = new WindowsLogger();

// Override console methods to use our logger
console.log = (...args) => {
  const message = args.map(arg => {
    if (typeof arg === 'object' && arg !== null) {
      try {
        return JSON.stringify(arg);
      } catch {
        return '[Unstringifiable Object]';
      }
    }
    return String(arg);
  }).join(' ');
  logger.log(message);
};

console.error = (...args) => {
  const errorInstance = args.find(arg => arg instanceof Error);
  const message = args
    .filter(arg => !(arg instanceof Error))
    .map(arg => {
      if (typeof arg === 'object' && arg !== null) {
        try {
          return JSON.stringify(arg);
        } catch {
          return '[Unstringifiable Object]';
        }
      }
      return String(arg);
    }).join(' ');
  
  logger.error(message, errorInstance);
};

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

const handleClipboardNext = () => {
  console.log('‚û°Ô∏è handleClipboardNext triggered!');
  if (!clipboardHistory) return;
  
  const entry = clipboardHistory.cycleNext();
  showPastille(); // Always show pastille to see current state
  if (entry) {
    console.log('üìã Next clipboard entry:', entry.text.substring(0, 50) + '...');
  }
};

const handleClipboardPrevious = () => {
  console.log('‚¨ÖÔ∏è handleClipboardPrevious triggered!');
  if (!clipboardHistory) return;
  
  const entry = clipboardHistory.cyclePrevious();
  showPastille(); // Always show pastille to see current state
  if (entry) {
    console.log('üìã Previous clipboard entry:', entry.text.substring(0, 50) + '...');
  }
};

const handleShowClipboard = () => {
  console.log('üëÅÔ∏è handleShowClipboard triggered!');
  showPastille(); // Show current clipboard state
};

const showPastille = () => {
  if (!pastilleWindow || !clipboardHistory) return;
  
  const currentEntry = clipboardHistory.getCurrentEntry();
  const currentIndex = clipboardHistory.getCurrentIndex();
  const totalCount = clipboardHistory.getHistoryLength();
  
  // Get fresh cursor position each time
  const cursorPosition = screen.getCursorScreenPoint();
  const { width: screenWidth, height: screenHeight } = screen.getPrimaryDisplay().workAreaSize;
  
  // Calculate position with bounds checking
  let x = cursorPosition.x + 20;
  let y = cursorPosition.y - 60;
  
  // Keep pastille on screen
  if (x + 520 > screenWidth) {
    x = cursorPosition.x - 540; // Show to the left of cursor
  }
  if (y < 0) {
    y = cursorPosition.y + 20; // Show below cursor
  }
  
  console.log('üñ±Ô∏è Cursor position:', cursorPosition, '-> Pastille position:', { x, y });
  
  pastilleWindow.setPosition(x, y);
  
  pastilleWindow.webContents.send('clipboard-updated', {
    entry: currentEntry,
    currentIndex: currentIndex,
    totalCount: totalCount
  });
  
  pastilleWindow.webContents.send('show-pastille');
  pastilleWindow.show(); // Make sure the window is shown
  console.log('üëÅÔ∏è Pastille window shown at cursor position');
};

// Utility to position pill near current cursor
const positionPillNearCursor = () => {
  if (!pastilleWindow) return;
  const cursorPosition = screen.getCursorScreenPoint();
  const { width: screenWidth, height: screenHeight } = screen.getPrimaryDisplay().workAreaSize;
  let x = cursorPosition.x + 20;
  let y = cursorPosition.y - 80;
  if (x + 520 > screenWidth) x = cursorPosition.x - 540;
  if (y < 0) y = cursorPosition.y + 20;
  pastilleWindow.setPosition(x, y);
};

const handleQuickEdit = async () => {
  console.log('üöÄ handleQuickEdit triggered!');
  const text = clipboard.readText();
  console.log('üìã Clipboard text:', text ? `"${text}"` : 'EMPTY');
  if (!text) {
    console.log('‚ùå No text in clipboard');
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', 'Quick Edit ‚Äì No text in clipboard!');
    pastilleWindow?.show();
    return;
  }

  console.log('‚è≥ Starting Quick Edit processing...');
  positionPillNearCursor();
  pastilleWindow?.webContents.send('show-processing', 'Processing');
  pastilleWindow?.show();

  // First try Python daemon quick edit
  let response: string | null = null;
  try {
    response = await callDaemonQuickEdit(text);
    console.log('üêç Daemon quick edit response:', response ? `"${response}"` : 'NULL');
  } catch (err) {
    console.error('üêç Daemon quick edit error:', (err as Error).message);
  }

  console.log('üìù Quick Edit response:', response ? `"${response}"` : 'NULL');

  if (response) {
    clipboard.writeText(response);
    console.log('‚úÖ Text processed and copied to clipboard');
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', response);
    pastilleWindow?.show();
  } else {
    console.log('‚ùå Failed to process text');
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', 'Quick Edit ‚Äì Failed to process text!');
    pastilleWindow?.show();
  }
};

const processRecording = async (filePath: string) => {
  try {
    console.log(`üîÑ Processing recording from ${filePath}`);
    const transcript = await callWhisperApi(filePath);
    console.log('üìù Whisper transcript:', transcript ? `"${transcript}"` : 'NULL');

    if (transcript) {
      // Save transcript to a file next to the recording
      const transcriptPath = filePath.replace('.wav', '.txt');
      fs.writeFileSync(transcriptPath, transcript);
      
      // Copy to clipboard
      clipboard.writeText(transcript);
      
      console.log(`üíæ Transcript saved to ${transcriptPath} and copied to clipboard`);
      positionPillNearCursor();
      pastilleWindow?.webContents.send('show-message', transcript);
      pastilleWindow?.show();
    } else {
      console.log('‚ùå Failed to transcribe audio');
      positionPillNearCursor();
      pastilleWindow?.webContents.send('show-message', 'Failed to transcribe audio.');
      pastilleWindow?.show();
    }
  } catch (e) {
    console.error('‚ùå Error processing recording:', e);
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', `Error ‚Äì Failed to process recording: ${e.message}`);
    pastilleWindow?.show();
  } finally {
    // Clean up the recording file
    // fs.unlink(filePath, (err) => {
    //   if (err) console.error(`Failed to delete audio file: ${filePath}`, err);
    //   else console.log(`Deleted audio file: ${filePath}`);
    // });
  }
};

const handleVoiceRecord = async () => {
  console.log('üé§ handleVoiceRecord triggered!');
  if (recorder && recorder.isRecording) {
    console.log('üõë Stopping recording...');
    recorder.stop();
    // Visualizer merged into pastille ‚Äì no separate window needed
    // stop showing waveform; pastille will switch to processing
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-processing', 'Processing');
    pastilleWindow?.show();
  } else {
    console.log('üéôÔ∏è Starting recording...');
    
    try {
      // Create recorder instance only if we don't have one
      if (!recorder) {
        console.log('üåê Using Web Audio API for recording');
        recorder = new WebAudioRecorder();

        // Set up event handlers only for new recorder instances
        recorder.on('audio-data', (data: Buffer) => {
          pastilleWindow?.webContents.send('audio-data', data);
        });

        recorder.on('finished', (filePath: string) => {
          console.log('‚úÖ Recording finished, file:', filePath);
          processRecording(filePath);
          // Don't reset recorder to null here - keep it for reuse
        });

        recorder.on('error', (error: any) => {
          console.log('‚ùå Recording error:', error);
          
          let userMessage = 'Recording Error';
          
          // Provide user-friendly error messages based on the error
          if (error.message.includes('permission denied')) {
            userMessage = 'Microphone access denied. Please allow microphone permissions in your system settings.';
          } else if (error.message.includes('No microphone found')) {
            userMessage = 'No microphone found. Please connect a microphone and try again.';
          } else if (error.message.includes('in use by another application')) {
            userMessage = 'Your microphone is busy. Please close other apps using it.';
          } else {
            userMessage = `Recording Error: ${error.message}`;
          }
          
          positionPillNearCursor();
          pastilleWindow?.webContents.send('show-message', userMessage);
          pastilleWindow?.show();
          
          // Show a more detailed dialog with action button
          setTimeout(() => {
            dialog.showMessageBox({
              type: 'warning',
              title: 'Audio Recording Issue',
              message: userMessage,
              detail: 'Would you like to open your audio settings?',
              buttons: ['Open Audio Settings', 'Cancel'],
              defaultId: 0
            }).then(result => {
              if (result.response === 0) {
                // Open settings window with focus on audio section
                openSettingsWindow();
              }
            });
          }, 2000);
          
          recorder = null; // Reset recorder
        });
      }

      // Check if recording is available before attempting to start
      const isAvailable = await recorder.isRecordingAvailable();
      if (!isAvailable) {
        console.log('‚ùå No recording method available');
        positionPillNearCursor();
        pastilleWindow?.webContents.send('show-message', 'Audio recording not available. Please check your microphone.');
        pastilleWindow?.show();
        recorder = null;
        return;
      }

      console.log('üîß Recording method:', recorder.getRecordingMethod());

      // Start recording (now async)
      await recorder.start();

      // Tell pastille to enter recording mode with waveform
      positionPillNearCursor();
      pastilleWindow?.webContents.send('start-recording', 'Recording... Press Ctrl+Alt+W to stop.');
      pastilleWindow?.show();

    } catch (error) {
      console.error('‚ùå Failed to start recording:', error);
      positionPillNearCursor();
      pastilleWindow?.webContents.send('show-message', `Recording Setup Error ‚Äì ${error.message}`);
      pastilleWindow?.show();
      recorder = null;
    }
  }
};

const handleTextToSpeech = async () => {
  console.log('üîä handleTextToSpeech triggered!');
  if (!config.OPENAI_API_KEY) {
    console.log('‚ùå No OpenAI API key found');
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', 'Configuration Error: OpenAI API key is not set.');
    pastilleWindow?.show();
    return;
  }

  const text = clipboard.readText();
  console.log('üìã Clipboard text for TTS:', text ? `"${text.substring(0, 100)}..."` : 'EMPTY');
  
  if (!text) {
    console.log('‚ùå No text in clipboard');
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', 'Text-to-Speech ‚Äì No text in clipboard!');
    pastilleWindow?.show();
    return;
  }

  // Stop any currently playing audio
  if (audioPlayer && audioPlayer.playing) {
    console.log('üõë Stopping current audio playback');
    audioPlayer.stop();
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', 'Audio playback stopped.');
    pastilleWindow?.show();
    return;
  }

  console.log('‚è≥ Starting TTS processing...');
  positionPillNearCursor();
  pastilleWindow?.webContents.send('show-processing', 'Generating speech');
  pastilleWindow?.show();

  try {
    const audioFilePath = await callTextToSpeechApi(text, config.TTS_VOICE);
    console.log('üéµ TTS response:', audioFilePath ? `"${audioFilePath}"` : 'NULL');

    if (audioFilePath) {
      console.log('üîä Starting audio playback...');
      positionPillNearCursor();
      pastilleWindow?.webContents.send('show-message', 'üîä Playing audio... (Ctrl+Alt+E to stop)');
      pastilleWindow?.show();

      // Initialize audio player if needed
      if (!audioPlayer) {
        audioPlayer = new AudioPlayer();
        
        audioPlayer.on('finished', () => {
          console.log('‚úÖ Audio playback finished');
          positionPillNearCursor();
          pastilleWindow?.webContents.send('show-message', 'Audio playback completed.');
          pastilleWindow?.show();
          
          // Clean up the temporary file
          setTimeout(() => {
            if (fs.existsSync(audioFilePath)) {
              fs.unlinkSync(audioFilePath);
              console.log('üóëÔ∏è Cleaned up temporary audio file');
            }
          }, 1000);
        });

        audioPlayer.on('error', (error) => {
          console.error('‚ùå Audio playback error:', error);
          positionPillNearCursor();
          pastilleWindow?.webContents.send('show-message', `Audio Error ‚Äì ${error.message}`);
          pastilleWindow?.show();
        });

        audioPlayer.on('stopped', () => {
          console.log('üõë Audio playback stopped');
        });
      }

      await audioPlayer.play(audioFilePath);
    } else {
      console.log('‚ùå Failed to generate speech');
      positionPillNearCursor();
      pastilleWindow?.webContents.send('show-message', 'Text-to-Speech ‚Äì Failed to generate audio!');
      pastilleWindow?.show();
    }
  } catch (error) {
    console.error('‚ùå TTS error:', error);
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', `TTS Error ‚Äì ${error.message}`);
    pastilleWindow?.show();
  }
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', async () => {
  console.log('üöÄ MetaKeyAI starting up...');
  
  // Setup microphone permission handler for Web Audio APIs
  console.log('üé§ Setting up microphone permission handler...');
  session.defaultSession.setPermissionRequestHandler((webContents, permission, callback) => {
    console.log('üîê Permission request:', permission);
    if (permission === 'media') {
      console.log('‚úÖ Granting microphone access for Web Audio APIs');
      callback(true); // Allow microphone access
    } else {
      console.log('‚ùå Denying permission:', permission);
      callback(false);
    }
  });
  
  // Create debug menu for Windows
  createDebugMenu();
  
  // Initialize components
  await initializeApp();
});

const openSettingsWindow = () => {
  // If settings window already exists, focus it
  if (settingsWindow) {
    settingsWindow.focus();
    return;
  }

  console.log('ü™ü Creating settings window...');
  settingsWindow = new BrowserWindow({
    width: 700,
    height: 900,
    minWidth: 600,
    minHeight: 700,
    title: 'MetaKeyAI Settings',
    icon: null, // You can add an icon here
    show: false,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false,
    },
  });

  settingsWindow.loadURL(SETTINGS_WINDOW_WEBPACK_ENTRY);

  settingsWindow.once('ready-to-show', () => {
    settingsWindow?.show();
    console.log('‚úÖ Settings window ready and shown');
  });

  settingsWindow.on('closed', () => {
    settingsWindow = null;
    console.log('üö™ Settings window closed');
  });
};

const openSpellBookWindow = () => {
  // If spell book window already exists, focus it
  if (spellBookWindow) {
    spellBookWindow.focus();
    return;
  }

  console.log('ü™ü Creating spell book window...');
  spellBookWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    minWidth: 800,
    minHeight: 600,
    title: 'Python Spell Book - MetaKeyAI',
    icon: null,
    show: false,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false,
    },
  });

  // Load the spell book HTML file
  spellBookWindow.loadURL(SPELL_BOOK_WINDOW_WEBPACK_ENTRY);

  spellBookWindow.once('ready-to-show', () => {
    spellBookWindow?.show();
    console.log('‚úÖ Spell book window ready and shown');
  });

  spellBookWindow.on('closed', () => {
    spellBookWindow = null;
    console.log('üö™ Spell book window closed');
  });
};

// Since there are no windows, we don't need to handle 'window-all-closed'
// The app will continue running in the background.

app.on('will-quit', () => {
  // Cleanup shortcuts manager
  if (shortcutsManager) {
    shortcutsManager.cleanup();
    shortcutsManager = null;
  }
  
  // Cleanup clipboard history
  if (clipboardHistory) {
    clipboardHistory.destroy();
    clipboardHistory = null;
  }
  
  // Cleanup audio player
  if (audioPlayer) {
    audioPlayer.stop();
    audioPlayer = null;
  }
  
  // Cleanup Python Spell Caster
  spellCaster?.cleanup();
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

/**
 * Shows a pill-style notification instead of the system notification.
 * Positions it near the bottom-right of the primary display.
 */
const showPillNotification = (message: string) => {
  if (!pastilleWindow) {
    console.warn('Pastille window not ready, cannot show pill notification');
    return;
  }

  const { width: screenWidth, height: screenHeight } = screen.getPrimaryDisplay().workAreaSize;

  const x = screenWidth - 500; // leave some margin
  const y = screenHeight - 100;

  pastilleWindow.setPosition(x, y);
  pastilleWindow.webContents.send('show-message', message);
  pastilleWindow.show();
};

// Add debug menu for Windows
function createDebugMenu() {
  if (process.platform === 'win32') {
    const { Menu } = require('electron');
    
    const debugMenu = Menu.buildFromTemplate([
      {
        label: 'Debug',
        submenu: [
          {
            label: 'Open Log File',
            click: () => {
              shell.openPath(logger.getLogPath());
            }
          },
          {
            label: 'Open Log Directory',
            click: () => {
              shell.showItemInFolder(logger.getLogPath());
            }
          },
          {
            label: 'Show Debug Info',
            click: () => {
              const info = {
                platform: process.platform,
                arch: process.arch,
                version: app.getVersion(),
                packaged: app.isPackaged,
                logFile: logger.getLogPath(),
                appData: app.getPath('appData'),
                userData: app.getPath('userData'),
                resourcesPath: process.resourcesPath || 'N/A'
              };
              
              dialog.showMessageBox({
                type: 'info',
                title: 'Debug Information',
                message: 'MetaKeyAI Debug Info',
                detail: JSON.stringify(info, null, 2),
                buttons: ['Copy to Clipboard', 'OK']
              }).then((result) => {
                if (result.response === 0) {
                  clipboard.writeText(JSON.stringify(info, null, 2));
                }
              });
            }
          },
          {
            label: 'Test Audio Recording',
            click: async () => {
              try {
                logger.log('üé§ Testing audio recording...');
                const audioRecorder = new WebAudioRecorder();
                await audioRecorder.start();
                setTimeout(async () => {
                  audioRecorder.stop();
                  logger.log(`‚úÖ Audio test completed`);
                  dialog.showMessageBox({
                    type: 'info',
                    title: 'Audio Test',
                    message: `Audio recording test completed! Check logs for details.`,
                    buttons: ['OK']
                  });
                }, 2000);
              } catch (error) {
                logger.error('Audio test failed', error);
                dialog.showErrorBox('Audio Test Failed', error.message);
              }
            }
          },
          {
            label: 'Test Audio Playback',
            click: async () => {
              try {
                logger.log('üîä Testing audio playback...');
                
                // Create a test audio file (simple beep)
                const testAudioPath = path.join(require('os').tmpdir(), 'test-beep.wav');
                
                // For now, just test with any existing audio file or show capabilities
                if (!audioPlayer) {
                  audioPlayer = new AudioPlayer();
                }
                
                // Test audio capabilities
                const capabilities = await testAudioCapabilities();
                
                dialog.showMessageBox({
                  type: 'info',
                  title: 'Audio Playback Test',
                  message: 'Audio Capabilities Test',
                  detail: JSON.stringify(capabilities, null, 2),
                  buttons: ['OK']
                });
                
              } catch (error) {
                logger.error('Audio playback test failed', error);
                dialog.showErrorBox('Audio Playback Test Failed', error.message);
              }
            }
          },
          {
            label: 'Generate Debug Report',
            click: async () => {
              try {
                const report = await generateDebugReport();
                const reportPath = path.join(logger.getLogDirectory(), `debug-report-${Date.now()}.json`);
                fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
                
                dialog.showMessageBox({
                  type: 'info',
                  title: 'Debug Report Generated',
                  message: `Debug report saved to:\n${reportPath}`,
                  buttons: ['Open Report', 'Open Folder', 'OK']
                }).then((result) => {
                  if (result.response === 0) {
                    shell.openPath(reportPath);
                  } else if (result.response === 1) {
                    shell.showItemInFolder(reportPath);
                  }
                });
              } catch (error) {
                logger.error('Failed to generate debug report', error);
                dialog.showErrorBox('Debug Report Failed', error.message);
              }
            }
          }
        ]
      }
    ]);
    
    Menu.setApplicationMenu(debugMenu);
  }
}

async function testAudioCapabilities() {
  const capabilities = {
    platform: process.platform,
    audioRecorderAvailable: false,
    audioPlayerAvailable: false,
    soxAvailable: false,
    ffmpegAvailable: false,
    powershellAvailable: false,
    windowsMediaPlayerAvailable: false,
    errors: [] as string[]
  };

  try {
    // Test audio recorder
    if (recorder) {
      capabilities.audioRecorderAvailable = true;
    }
  } catch (error: any) {
    capabilities.errors.push(`Audio recorder test failed: ${error.message}`);
  }

  try {
    // Test audio player
    if (audioPlayer) {
      capabilities.audioPlayerAvailable = true;
    }
  } catch (error: any) {
    capabilities.errors.push(`Audio player test failed: ${error.message}`);
  }

  // Test Sox availability
  try {
    const { spawn } = require('child_process');
    await new Promise((resolve, reject) => {
      const proc = spawn('sox', ['--version'], { stdio: 'pipe' });
      proc.on('close', (code: number) => {
        if (code === 0) {
          capabilities.soxAvailable = true;
          resolve(true);
        } else {
          reject(new Error(`Sox test failed with code ${code}`));
        }
      });
      proc.on('error', reject);
      setTimeout(() => {
        proc.kill();
        reject(new Error('Sox test timed out'));
      }, 3000);
    });
  } catch (error: any) {
    capabilities.errors.push(`Sox test failed: ${error.message}`);
  }

  // Test FFmpeg availability
  try {
    const { spawn } = require('child_process');
    await new Promise((resolve, reject) => {
      const proc = spawn('ffmpeg', ['-version'], { stdio: 'pipe' });
      proc.on('close', (code: number) => {
        if (code === 0) {
          capabilities.ffmpegAvailable = true;
          resolve(true);
        } else {
          reject(new Error(`FFmpeg test failed with code ${code}`));
        }
      });
      proc.on('error', reject);
      setTimeout(() => {
        proc.kill();
        reject(new Error('FFmpeg test timed out'));
      }, 3000);
    });
  } catch (error: any) {
    capabilities.errors.push(`FFmpeg test failed: ${error.message}`);
  }

  // Windows-specific tests
  if (process.platform === 'win32') {
    // Test PowerShell
    try {
      const { spawn } = require('child_process');
      await new Promise((resolve, reject) => {
        const proc = spawn('powershell', ['-Command', 'Write-Output "PowerShell available"'], { stdio: 'pipe' });
        proc.on('close', (code: number) => {
          if (code === 0) {
            capabilities.powershellAvailable = true;
            resolve(true);
          } else {
            reject(new Error(`PowerShell test failed with code ${code}`));
          }
        });
        proc.on('error', reject);
        setTimeout(() => {
          proc.kill();
          reject(new Error('PowerShell test timed out'));
        }, 3000);
      });
    } catch (error: any) {
      capabilities.errors.push(`PowerShell test failed: ${error.message}`);
    }

    // Test Windows Media Player
    const wmplayerPaths = [
      'C:\\Program Files\\Windows Media Player\\wmplayer.exe',
      'C:\\Program Files (x86)\\Windows Media Player\\wmplayer.exe'
    ];
    
    for (const wmplayerPath of wmplayerPaths) {
      if (fs.existsSync(wmplayerPath)) {
        capabilities.windowsMediaPlayerAvailable = true;
        break;
      }
    }
  }

  return capabilities;
}

async function generateDebugReport() {
  const report: any = {
    timestamp: new Date().toISOString(),
    system: {
      platform: process.platform,
      arch: process.arch,
      nodeVersion: process.version,
      electronVersion: process.versions.electron,
      appVersion: app.getVersion(),
      isPackaged: app.isPackaged,
      appPath: app.getAppPath(),
      userData: app.getPath('userData'),
      resourcesPath: process.resourcesPath || 'N/A'
    },
    audio: await testAudioCapabilities(),
    environment: {
      NODE_ENV: process.env.NODE_ENV,
      PATH: process.env.PATH,
      APPDATA: process.env.APPDATA,
      LOCALAPPDATA: process.env.LOCALAPPDATA,
      PROGRAMFILES: process.env.PROGRAMFILES,
      'PROGRAMFILES(X86)': process.env['PROGRAMFILES(X86)']
    },
    files: {
      logFile: logger.getLogPath(),
      logDirectory: logger.getLogDirectory(),
      configExists: fs.existsSync(ENV_CONFIG_PATH),
      configPath: ENV_CONFIG_PATH
    },
    components: {
      recorder: !!recorder,
      audioPlayer: !!audioPlayer,
      clipboardHistory: !!clipboardHistory,
      shortcutsManager: !!shortcutsManager,
      tray: !!tray
    }
  };

  // Add recent log entries
  try {
    const logContent = fs.readFileSync(logger.getLogPath(), 'utf-8');
    const logLines = logContent.split('\n').slice(-50); // Last 50 lines
    report.recentLogs = logLines.filter(line => line.trim());
  } catch (error: any) {
    report.recentLogs = [`Failed to read log file: ${error.message}`];
  }

  return report;
}

async function initializeApp() {
  console.log('üìã Initializing clipboard history...');
  clipboardHistory = new ClipboardHistory(50);
  
  clipboardHistory.on('history-updated', (entry) => {
    console.log('üìã Clipboard history updated:', entry?.text?.substring(0, 50) + '...');
  });
  
  clipboardHistory.on('current-changed', (entry) => {
    console.log('üìã Current clipboard entry changed:', entry?.text?.substring(0, 50) + '...');
  });
  
  console.log('‚úÖ Clipboard history initialized');
  
  // Initialize Python Spell Caster
  console.log('üßô‚Äç‚ôÇÔ∏è Initializing Python Spell Caster...');
  try {
    spellCaster = pythonSpellCaster; // Use the exported instance
    await spellCaster.initialize();
    console.log('‚úÖ Python Spell Caster initialized');
  } catch (error) {
    console.error('‚ùå Failed to initialize Python Spell Caster:', error);
  }
  
  // Create the pastille window
  console.log('ü™ü Creating pastille window...');
  pastilleWindow = new BrowserWindow({
    width: 500,
    height: 70,
    frame: false,
    transparent: true,
    alwaysOnTop: false,
    show: false,
    resizable: true,
    skipTaskbar: true,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false,
    },
  });

  pastilleWindow.loadURL(PASTILLE_WINDOW_WEBPACK_ENTRY);
  (global as any).pastilleWindow = pastilleWindow; // Make window accessible to other modules
  pastilleWindow.setIgnoreMouseEvents(false);
  
  // Initialize pastille with current clipboard content once it's ready
  pastilleWindow.webContents.once('did-finish-load', () => {
    console.log('üéØ Pastille window loaded, initializing with current clipboard');
    setTimeout(() => {
      const currentEntry = clipboardHistory?.getCurrentEntry();
      const currentIndex = clipboardHistory?.getCurrentIndex() ?? -1;
      const totalCount = clipboardHistory?.getHistoryLength() ?? 0;
      
      pastilleWindow?.webContents.send('clipboard-updated', {
        entry: currentEntry,
        currentIndex: currentIndex,
        totalCount: totalCount
      });
    }, 100);
  });
  
  console.log('‚úÖ Pastille window created');

  // Create tray icon
  console.log('üñºÔ∏è Creating tray icon...');
  const image = nativeImage.createFromDataURL(
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAEklEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='
  );
  tray = new Tray(image);
  
  const contextMenu = Menu.buildFromTemplate([
    { label: 'Exit', type: 'normal', click: () => app.quit() },
  ]);

  tray.setToolTip('MetaKeyAI');
  tray.setContextMenu(contextMenu);
  console.log('‚úÖ Tray created');
  
  showPillNotification('MetaKeyAI running in background\nCtrl+Alt+Q: Quick edit\nCtrl+Alt+W: Voice record\nCtrl+Alt+E: Text-to-speech\nCtrl+Alt+C: Show clipboard\nCtrl+Alt+‚Üê/‚Üí/Num-/Num/: Navigate clipboard\nCustomize shortcuts in Settings!');

  if (!config.OPENAI_API_KEY) {
    console.log('‚ö†Ô∏è No OpenAI API key found in config');
    showPillNotification('Configuration Warning ‚Äì OpenAI API key not set. Voice and edit features will not work.');
  } else {
    console.log('‚úÖ OpenAI API key found in config');
  }

  // Initialize shortcuts manager (logging handled inside ShortcutsManager)
  shortcutsManager = ShortcutsManager.getInstance();
  
  // Define all shortcut handlers
  const shortcutHandlers = {
    'quick-edit': handleQuickEdit,
    'voice-record': handleVoiceRecord,
    'text-to-speech': handleTextToSpeech,
    'clipboard-show': handleShowClipboard,
    'clipboard-next': handleClipboardNext,
    'clipboard-previous': handleClipboardPrevious,
    'clipboard-next-alt1': handleClipboardNext,
    'clipboard-previous-alt1': handleClipboardPrevious,
    'clipboard-next-alt2': handleClipboardNext,
    'clipboard-previous-alt2': handleClipboardPrevious,
    'spells-analysis': async () => {
      const clipboardContent = clipboard.readText();
      const spells = spellCaster?.getSpellBook().filter((s: any) => s.category === 'analysis') || [];
      if (spells.length > 0) {
        await spellCaster?.castSpell(spells[0].id, clipboardContent);
      }
    },
    'spells-data': async () => {
      const clipboardContent = clipboard.readText();
      const spells = spellCaster?.getSpellBook().filter((s: any) => s.category === 'data') || [];
      if (spells.length > 0) {
        await spellCaster?.castSpell(spells[0].id, clipboardContent);
      }
    },
    'spells-text': async () => {
      const clipboardContent = clipboard.readText();
      const spells = spellCaster?.getSpellBook().filter((s: any) => s.category === 'text') || [];
      if (spells.length > 0) {
        await spellCaster?.castSpell(spells[0].id, clipboardContent);
      }
    },
    // Quick spell slots
    'spell-slot-1': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        await spellCaster?.castQuickSpell(1, clipboardContent);
      } catch (error) {
        console.warn('‚ö†Ô∏è Quick spell slot 1:', (error as Error).message);
        showPillNotification('No spell assigned to slot 1');
      }
    },
    'spell-slot-2': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        await spellCaster?.castQuickSpell(2, clipboardContent);
      } catch (error) {
        console.warn('‚ö†Ô∏è Quick spell slot 2:', (error as Error).message);
        showPillNotification('No spell assigned to slot 2');
      }
    },
    'spell-slot-3': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        await spellCaster?.castQuickSpell(3, clipboardContent);
      } catch (error) {
        console.warn('‚ö†Ô∏è Quick spell slot 3:', (error as Error).message);
        showPillNotification('No spell assigned to slot 3');
      }
    },
    'spell-slot-4': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        await spellCaster?.castQuickSpell(4, clipboardContent);
      } catch (error) {
        console.warn('‚ö†Ô∏è Quick spell slot 4:', (error as Error).message);
        showPillNotification('No spell assigned to slot 4');
      }
    },
    'spell-slot-5': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        await spellCaster?.castQuickSpell(5, clipboardContent);
      } catch (error) {
        console.warn('‚ö†Ô∏è Quick spell slot 5:', (error as Error).message);
        showPillNotification('No spell assigned to slot 5');
      }
    },
    'spell-slot-6': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        await spellCaster?.castQuickSpell(6, clipboardContent);
      } catch (error) {
        console.warn('‚ö†Ô∏è Quick spell slot 6:', (error as Error).message);
        showPillNotification('No spell assigned to slot 6');
      }
    },
    'spell-slot-7': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        await spellCaster?.castQuickSpell(7, clipboardContent);
      } catch (error) {
        console.warn('‚ö†Ô∏è Quick spell slot 7:', (error as Error).message);
        showPillNotification('No spell assigned to slot 7');
      }
    },
    'spell-slot-8': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        await spellCaster?.castQuickSpell(8, clipboardContent);
      } catch (error) {
        console.warn('‚ö†Ô∏è Quick spell slot 8:', (error as Error).message);
        showPillNotification('No spell assigned to slot 8');
      }
    },
    'spell-slot-9': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        await spellCaster?.castQuickSpell(9, clipboardContent);
      } catch (error) {
        console.warn('‚ö†Ô∏è Quick spell slot 9:', (error as Error).message);
        showPillNotification('No spell assigned to slot 9');
      }
    },
  };
  
  await shortcutsManager.initialize(shortcutHandlers);

  // Add IPC listeners
  setupIpcListeners();
}

function setupIpcListeners() {
  // Add IPC listener for update-clipboard
  ipcMain.on('update-clipboard', (event, text) => {
    console.log('üìã Received update-clipboard event:', text);
    clipboard.writeText(text);
    showPastille();
  });
  
  // Add IPC listener for update-clipboard-draft (real-time editing)
  ipcMain.on('update-clipboard-draft', (event, text) => {
    console.log('üìù Received update-clipboard-draft event:', text.substring(0, 50) + '...');
    clipboard.writeText(text);
    // Don't show pastille for draft updates to avoid interrupting editing
  });

  // Add IPC listener for expand-pastille
  ipcMain.on('expand-pastille', () => {
    if (pastilleWindow) {
      const { width: screenWidth, height: screenHeight } = screen.getPrimaryDisplay().workAreaSize;
      const targetWidth = Math.round(screenWidth * 0.7);
      const targetHeight = Math.round(screenHeight * 0.6);
      pastilleWindow.setAlwaysOnTop(true);
      pastilleWindow.setSize(targetWidth, targetHeight, true);
      pastilleWindow.center();
    }
  });

  // Add IPC listener for collapse-pastille
  ipcMain.on('collapse-pastille', () => {
    if (pastilleWindow) {
      pastilleWindow.setSize(500, 70, true);
      pastilleWindow.setAlwaysOnTop(false);
    }
  });

  // Add IPC listener for clipboard navigation from control bar
  ipcMain.on('clipboard-navigate', (event, direction) => {
    console.log('üîÑ Received clipboard-navigate event:', direction);
    if (direction === 'next') {
      handleClipboardNext();
    } else if (direction === 'previous') {
      handleClipboardPrevious();
    }
  });

  // Add IPC listener for opening settings
  ipcMain.on('open-settings', () => {
    console.log('‚öôÔ∏è Opening settings window...');
    openSettingsWindow();
  });

  // Add IPC listener for opening spell book
  ipcMain.on('open-spell-book', () => {
    console.log('üßô‚Äç‚ôÇÔ∏è Opening spell book window...');
    openSpellBookWindow();
  });

  // Add IPC listeners for settings management
  ipcMain.on('load-settings', (event) => {
    console.log('üìã Loading settings for dashboard...');
    const settings = {
      OPENAI_API_KEY: config.OPENAI_API_KEY || '',
      WHISPER_MODEL: config.WHISPER_MODEL,
      TTS_VOICE: config.TTS_VOICE,
      MICROPHONE_DEVICE: recorder?.getUserAudioDevice() || 'auto'
    };
    event.reply('settings-loaded', settings);
  });

  ipcMain.on('save-settings', (event, newSettings) => {
    console.log('üíæ Saving settings from dashboard...');
    try {
      // Update config object (note: this only updates runtime, not persistent storage)
      config.OPENAI_API_KEY = newSettings.OPENAI_API_KEY;
      config.WHISPER_MODEL = newSettings.WHISPER_MODEL;
      config.TTS_VOICE = newSettings.TTS_VOICE;
      
      // Update microphone device if provided
      if (newSettings.MICROPHONE_DEVICE !== undefined && recorder) {
        if (newSettings.MICROPHONE_DEVICE === 'auto') {
          recorder.setUserAudioDevice('');
        } else {
          recorder.setUserAudioDevice(newSettings.MICROPHONE_DEVICE);
        }
      }
      
      console.log('‚úÖ Settings updated successfully');
      event.reply('settings-saved', true, 'Settings saved successfully!');
    } catch (error) {
      console.error('‚ùå Error saving settings:', error);
      event.reply('settings-saved', false, 'Failed to save settings: ' + (error as Error).message);
    }
  });

  ipcMain.on('validate-api-key', async (event, apiKey) => {
    console.log('üîç Validating API key...');
    try {
      // Simple validation - try to make a basic API call with timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000);
      
      const response = await fetch('https://api.openai.com/v1/models', {
        headers: {
          'Authorization': `Bearer ${apiKey}`,
        },
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);
      const isValid = response.ok;
      console.log('üîë API key validation result:', isValid);
      event.reply('api-key-validated', isValid);
    } catch (error) {
      console.log('‚ùå API key validation failed:', error.message);
      event.reply('api-key-validated', false);
    }
  });

  ipcMain.on('test-voice', async (event, { voice, text }) => {
    console.log('üîä Testing voice from settings:', voice);
    try {
      const audioFilePath = await callTextToSpeechApi(text, voice);
      if (audioFilePath && audioPlayer) {
        await audioPlayer.play(audioFilePath);
      }
    } catch (error) {
      console.error('‚ùå Voice test error:', error);
    }
  });

  // Add IPC for environment variables
  ipcMain.handle('load-env', () => {
    return readEnvConfig();
  });

  ipcMain.handle('save-env', async (event, { env, llm, llms }) => {
    try {
      // Persist to disk (includes llms list)
      writeEnvConfig({ env, llm, llms });

      // Apply to current process env and config
      Object.entries(env).forEach(([k,v]) => process.env[k]=v as string);
      if (llm) process.env['METAKEYAI_LLM'] = llm;

      (config as any).ENV_VARS = env;
      (config as any).DEFAULT_LLM = llm;
      (config as any).LLM_LIST = llms;

      // Notify daemon
      const daemon = await PythonDaemon.getInstance();
      const res = await daemon.updateEnv({ ...env, METAKEYAI_LLM: llm });
      return { ok: res?.ok !== false, msg: res?.msg || '' };
    } catch (err) {
      return { ok: false, msg: (err as Error).message };
    }
  });

  // The settings window handles its own device discovery and testing.
  // We only need a listener to save the user's chosen device for future recordings.
  ipcMain.on('set-microphone-device', (event, deviceName) => {
    try {
      console.log('üé§ Setting microphone device:', deviceName);
      
      if (recorder) {
        // If recorder already exists, use it
        recorder.setUserAudioDevice(deviceName === 'auto' ? '' : deviceName);
      } else {
        // Create a temporary instance just to save the setting to disk.
        // The main recorder will be created on first use and will load this setting.
        const tempRecorder = new WebAudioRecorder();
        tempRecorder.setUserAudioDevice(deviceName === 'auto' ? '' : deviceName);
        console.log('üé§ Saved microphone setting via temporary recorder instance.');
      }
    } catch (error) {
      console.error('‚ùå Error setting microphone device:', error);
    }
  });
}
