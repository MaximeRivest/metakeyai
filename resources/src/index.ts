import { app, Tray, Menu, globalShortcut, clipboard, nativeImage, BrowserWindow, screen, ipcMain } from 'electron';
import fs from 'fs';
import path from 'path';
import { callWhisperApi, callTextToSpeechApi } from './openai-api';
import { callDaemonQuickEdit } from './python-daemon-api';
import { config } from './config';
import { AudioRecorder } from './audio-recorder';
import { ClipboardHistory } from './clipboard-history';
import { AudioPlayer } from './audio-player';
import { pythonSpellCaster } from './python-spells';
import { ShortcutsManager } from './shortcuts-manager';
import { PythonDaemon } from './python-daemon';

// This allows TypeScript to pick up the magic constants that are auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code.
// We don't have a window anymore, but we'll keep these for potential future use.
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const VISUALIZER_WINDOW_WEBPACK_ENTRY: string;
declare const VISUALIZER_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const PASTILLE_WINDOW_WEBPACK_ENTRY: string;
declare const PASTILLE_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const SETTINGS_WINDOW_WEBPACK_ENTRY: string;
declare const SETTINGS_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const SPELL_BOOK_WINDOW_WEBPACK_ENTRY: string;
declare const SPELL_BOOK_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

let tray: Tray | null = null;
let recorder: AudioRecorder | null = null;
let visualizerWindow: null = null;
let pastilleWindow: BrowserWindow | null = null;
let settingsWindow: BrowserWindow | null = null;
let spellBookWindow: BrowserWindow | null = null;
let clipboardHistory: ClipboardHistory | null = null;
let audioPlayer: AudioPlayer | null = null;
let shortcutsManager: ShortcutsManager | null = null;

// Persistent env config path and helpers
const ENV_CONFIG_PATH = path.join(app.getPath('userData'), 'env_config.json');

interface EnvConfigFile { env: Record<string,string>; llm: string; llms?: string[]; }

function readEnvConfig(): EnvConfigFile {
  try {
    if (fs.existsSync(ENV_CONFIG_PATH)) {
      return JSON.parse(fs.readFileSync(ENV_CONFIG_PATH, 'utf-8')) as EnvConfigFile;
    }
  } catch {}
  return { env: {}, llm: '', llms: [] };
}

function writeEnvConfig(data: EnvConfigFile) {
  try {
    fs.mkdirSync(path.dirname(ENV_CONFIG_PATH), { recursive: true });
    fs.writeFileSync(ENV_CONFIG_PATH, JSON.stringify(data, null, 2), 'utf-8');
  } catch (err) {
    console.error('‚ùå Failed to persist env config', err);
  }
}

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

const handleClipboardNext = () => {
  console.log('‚û°Ô∏è handleClipboardNext triggered!');
  if (!clipboardHistory) return;
  
  const entry = clipboardHistory.cycleNext();
  showPastille(); // Always show pastille to see current state
  if (entry) {
    console.log('üìã Next clipboard entry:', entry.text.substring(0, 50) + '...');
  }
};

const handleClipboardPrevious = () => {
  console.log('‚¨ÖÔ∏è handleClipboardPrevious triggered!');
  if (!clipboardHistory) return;
  
  const entry = clipboardHistory.cyclePrevious();
  showPastille(); // Always show pastille to see current state
  if (entry) {
    console.log('üìã Previous clipboard entry:', entry.text.substring(0, 50) + '...');
  }
};

const handleShowClipboard = () => {
  console.log('üëÅÔ∏è handleShowClipboard triggered!');
  showPastille(); // Show current clipboard state
};

const showPastille = () => {
  if (!pastilleWindow || !clipboardHistory) return;
  
  const currentEntry = clipboardHistory.getCurrentEntry();
  const currentIndex = clipboardHistory.getCurrentIndex();
  const totalCount = clipboardHistory.getHistoryLength();
  
  // Get fresh cursor position each time
  const cursorPosition = screen.getCursorScreenPoint();
  const { width: screenWidth, height: screenHeight } = screen.getPrimaryDisplay().workAreaSize;
  
  // Calculate position with bounds checking
  let x = cursorPosition.x + 20;
  let y = cursorPosition.y - 60;
  
  // Keep pastille on screen
  if (x + 520 > screenWidth) {
    x = cursorPosition.x - 540; // Show to the left of cursor
  }
  if (y < 0) {
    y = cursorPosition.y + 20; // Show below cursor
  }
  
  console.log('üñ±Ô∏è Cursor position:', cursorPosition, '-> Pastille position:', { x, y });
  
  pastilleWindow.setPosition(x, y);
  
  pastilleWindow.webContents.send('clipboard-updated', {
    entry: currentEntry,
    currentIndex: currentIndex,
    totalCount: totalCount
  });
  
  pastilleWindow.webContents.send('show-pastille');
  pastilleWindow.show(); // Make sure the window is shown
  console.log('üëÅÔ∏è Pastille window shown at cursor position');
};

// Utility to position pill near current cursor
const positionPillNearCursor = () => {
  if (!pastilleWindow) return;
  const cursorPosition = screen.getCursorScreenPoint();
  const { width: screenWidth, height: screenHeight } = screen.getPrimaryDisplay().workAreaSize;
  let x = cursorPosition.x + 20;
  let y = cursorPosition.y - 80;
  if (x + 520 > screenWidth) x = cursorPosition.x - 540;
  if (y < 0) y = cursorPosition.y + 20;
  pastilleWindow.setPosition(x, y);
};

const handleQuickEdit = async () => {
  console.log('üöÄ handleQuickEdit triggered!');
  const text = clipboard.readText();
  console.log('üìã Clipboard text:', text ? `"${text}"` : 'EMPTY');
  if (!text) {
    console.log('‚ùå No text in clipboard');
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', 'Quick Edit ‚Äì No text in clipboard!');
    pastilleWindow?.show();
    return;
  }

  console.log('‚è≥ Starting Quick Edit processing...');
  positionPillNearCursor();
  pastilleWindow?.webContents.send('show-processing', 'Processing');
  pastilleWindow?.show();

  // First try Python daemon quick edit
  let response: string | null = null;
  try {
    response = await callDaemonQuickEdit(text);
    console.log('üêç Daemon quick edit response:', response ? `"${response}"` : 'NULL');
  } catch (err) {
    console.error('üêç Daemon quick edit error:', (err as Error).message);
  }

  console.log('üìù Quick Edit response:', response ? `"${response}"` : 'NULL');

  if (response) {
    clipboard.writeText(response);
    console.log('‚úÖ Text processed and copied to clipboard');
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', response);
    pastilleWindow?.show();
  } else {
    console.log('‚ùå Failed to process text');
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', 'Quick Edit ‚Äì Failed to process text!');
    pastilleWindow?.show();
  }
};

const processRecording = async (filePath: string) => {
  try {
    console.log(`üîÑ Processing recording from ${filePath}`);
    const transcript = await callWhisperApi(filePath);
    console.log('üìù Whisper transcript:', transcript ? `"${transcript}"` : 'NULL');

    if (transcript) {
      // Save transcript to a file next to the recording
      const transcriptPath = filePath.replace('.wav', '.txt');
      fs.writeFileSync(transcriptPath, transcript);
      
      // Copy to clipboard
      clipboard.writeText(transcript);
      
      console.log(`üíæ Transcript saved to ${transcriptPath} and copied to clipboard`);
      positionPillNearCursor();
      pastilleWindow?.webContents.send('show-message', transcript);
      pastilleWindow?.show();
    } else {
      console.log('‚ùå Failed to transcribe audio');
      positionPillNearCursor();
      pastilleWindow?.webContents.send('show-message', 'Failed to transcribe audio.');
      pastilleWindow?.show();
    }
  } catch (e) {
    console.error('‚ùå Error processing recording:', e);
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', `Error ‚Äì Failed to process recording: ${e.message}`);
    pastilleWindow?.show();
  } finally {
    // Clean up the recording file
    // fs.unlink(filePath, (err) => {
    //   if (err) console.error(`Failed to delete audio file: ${filePath}`, err);
    //   else console.log(`Deleted audio file: ${filePath}`);
    // });
  }
};

const handleVoiceRecord = async () => {
  console.log('üé§ handleVoiceRecord triggered!');
  if (recorder && recorder.isRecording) {
    console.log('üõë Stopping recording...');
    recorder.stop();
    // Visualizer merged into pastille ‚Äì no separate window needed
    // stop showing waveform; pastille will switch to processing
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-processing', 'Processing');
    pastilleWindow?.show();
  } else {
    console.log('üéôÔ∏è Starting recording...');
    
    try {
      recorder = new AudioRecorder();

      // Set up event handlers before starting
      recorder.on('audio-data', (data: Buffer) => {
        pastilleWindow?.webContents.send('audio-data', data);
      });

      recorder.on('finished', (filePath: string) => {
        console.log('‚úÖ Recording finished, file:', filePath);
        processRecording(filePath);
        recorder = null; // Reset recorder
      });

      recorder.on('error', (error: any) => {
        console.log('‚ùå Recording error:', error);
        positionPillNearCursor();
        pastilleWindow?.webContents.send('show-message', `Recording Error ‚Äì ${error.message}`);
        pastilleWindow?.show();
        recorder = null; // Reset recorder
      });

      // Check if recording is available before attempting to start
      const isAvailable = await recorder.isRecordingAvailable();
      if (!isAvailable) {
        console.log('‚ùå No recording method available');
        positionPillNearCursor();
        pastilleWindow?.webContents.send('show-message', 'Audio recording not available. Please run: npm run setup-audio');
        pastilleWindow?.show();
        recorder = null;
        return;
      }

      console.log('üîß Recording method:', recorder.getRecordingMethod());

      // Start recording (now async)
      await recorder.start();

      // Tell pastille to enter recording mode with waveform
      positionPillNearCursor();
      pastilleWindow?.webContents.send('start-recording', 'Recording... Press Ctrl+Alt+W to stop.');
      pastilleWindow?.show();

    } catch (error) {
      console.error('‚ùå Failed to start recording:', error);
      positionPillNearCursor();
      pastilleWindow?.webContents.send('show-message', `Recording Setup Error ‚Äì ${error.message}`);
      pastilleWindow?.show();
      recorder = null;
    }
  }
};

const handleTextToSpeech = async () => {
  console.log('üîä handleTextToSpeech triggered!');
  if (!config.OPENAI_API_KEY) {
    console.log('‚ùå No OpenAI API key found');
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', 'Configuration Error: OpenAI API key is not set.');
    pastilleWindow?.show();
    return;
  }

  const text = clipboard.readText();
  console.log('üìã Clipboard text for TTS:', text ? `"${text.substring(0, 100)}..."` : 'EMPTY');
  
  if (!text) {
    console.log('‚ùå No text in clipboard');
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', 'Text-to-Speech ‚Äì No text in clipboard!');
    pastilleWindow?.show();
    return;
  }

  // Stop any currently playing audio
  if (audioPlayer && audioPlayer.playing) {
    console.log('üõë Stopping current audio playback');
    audioPlayer.stop();
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', 'Audio playback stopped.');
    pastilleWindow?.show();
    return;
  }

  console.log('‚è≥ Starting TTS processing...');
  positionPillNearCursor();
  pastilleWindow?.webContents.send('show-processing', 'Generating speech');
  pastilleWindow?.show();

  try {
    const audioFilePath = await callTextToSpeechApi(text, config.TTS_VOICE);
    console.log('üéµ TTS response:', audioFilePath ? `"${audioFilePath}"` : 'NULL');

    if (audioFilePath) {
      console.log('üîä Starting audio playback...');
      positionPillNearCursor();
      pastilleWindow?.webContents.send('show-message', 'üîä Playing audio... (Ctrl+Alt+E to stop)');
      pastilleWindow?.show();

      // Initialize audio player if needed
      if (!audioPlayer) {
        audioPlayer = new AudioPlayer();
        
        audioPlayer.on('finished', () => {
          console.log('‚úÖ Audio playback finished');
          positionPillNearCursor();
          pastilleWindow?.webContents.send('show-message', 'Audio playback completed.');
          pastilleWindow?.show();
          
          // Clean up the temporary file
          setTimeout(() => {
            if (fs.existsSync(audioFilePath)) {
              fs.unlinkSync(audioFilePath);
              console.log('üóëÔ∏è Cleaned up temporary audio file');
            }
          }, 1000);
        });

        audioPlayer.on('error', (error) => {
          console.error('‚ùå Audio playback error:', error);
          positionPillNearCursor();
          pastilleWindow?.webContents.send('show-message', `Audio Error ‚Äì ${error.message}`);
          pastilleWindow?.show();
        });

        audioPlayer.on('stopped', () => {
          console.log('üõë Audio playback stopped');
        });
      }

      await audioPlayer.play(audioFilePath);
    } else {
      console.log('‚ùå Failed to generate speech');
      positionPillNearCursor();
      pastilleWindow?.webContents.send('show-message', 'Text-to-Speech ‚Äì Failed to generate audio!');
      pastilleWindow?.show();
    }
  } catch (error) {
    console.error('‚ùå TTS error:', error);
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', `TTS Error ‚Äì ${error.message}`);
    pastilleWindow?.show();
  }
};

app.on('ready', async () => {
  console.log('üöÄ App ready event triggered');
  
  // Initialize clipboard history
  console.log('üìã Initializing clipboard history...');
  clipboardHistory = new ClipboardHistory(50);
  
  clipboardHistory.on('history-updated', (entry) => {
    console.log('üìã Clipboard history updated:', entry?.text?.substring(0, 50) + '...');
  });
  
  clipboardHistory.on('current-changed', (entry) => {
    console.log('üìã Current clipboard entry changed:', entry?.text?.substring(0, 50) + '...');
  });
  
  console.log('‚úÖ Clipboard history initialized');
  
  // Initialize Python Spell Caster
  console.log('üßô‚Äç‚ôÇÔ∏è Initializing Python Spell Caster...');
  try {
    await pythonSpellCaster.initialize();
    console.log('‚úÖ Python Spell Caster initialized');
  } catch (error) {
    console.error('‚ùå Failed to initialize Python Spell Caster:', error);
  }
  
  // Create the visualizer window
  console.log('ü™ü Creating visualizer window...');
  // Visualizer merged into pastille ‚Äì no separate window needed
  // let visualizerWindow = new BrowserWindow({
  //   width: 200,
  //   height: 60,
  //   frame: false,
  //   transparent: true,
  //   alwaysOnTop: true,
  //   show: false,
  //   resizable: false,
  //   webPreferences: {
  //     nodeIntegration: true,
  //     contextIsolation: false, // Needed for ipcRenderer in visualizer.ts without a preload script
  //   },
  // });

  // visualizerWindow.loadURL(VISUALIZER_WINDOW_WEBPACK_ENTRY);
  // visualizerWindow.setIgnoreMouseEvents(true); // Make the window click-through
  // console.log('‚úÖ Visualizer window created');
  
  // Create the pastille window
  console.log('ü™ü Creating pastille window...');
  pastilleWindow = new BrowserWindow({
    width: 500,
    height: 70,
    frame: false,
    transparent: true,
    alwaysOnTop: false,
    show: false,
    resizable: true,
    skipTaskbar: true,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false, // Needed for ipcRenderer in pastille.ts without a preload script
    },
  });

  pastilleWindow.loadURL(PASTILLE_WINDOW_WEBPACK_ENTRY);
  // Allow mouse events so user can drag the pill
  pastilleWindow.setIgnoreMouseEvents(false);
  
  // Initialize pastille with current clipboard content once it's ready
  pastilleWindow.webContents.once('did-finish-load', () => {
    console.log('üéØ Pastille window loaded, initializing with current clipboard');
    setTimeout(() => {
      const currentEntry = clipboardHistory?.getCurrentEntry();
      const currentIndex = clipboardHistory?.getCurrentIndex() ?? -1;
      const totalCount = clipboardHistory?.getHistoryLength() ?? 0;
      
      pastilleWindow?.webContents.send('clipboard-updated', {
        entry: currentEntry,
        currentIndex: currentIndex,
        totalCount: totalCount
      });
    }, 100);
  });
  
  console.log('‚úÖ Pastille window created');

  // We don't want a window, just a tray icon.
  // Create a native image from a data URL for the tray icon.
  // This is a simple 16x16 transparent PNG.
  console.log('üñºÔ∏è Creating tray icon...');
  const image = nativeImage.createFromDataURL(
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAEklEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='
  );
  tray = new Tray(image);
  
  const contextMenu = Menu.buildFromTemplate([
    { label: 'Exit', type: 'normal', click: () => app.quit() },
  ]);

  tray.setToolTip('MetaKeyAI');
  tray.setContextMenu(contextMenu);
  console.log('‚úÖ Tray created');
  
  showPillNotification('MetaKeyAI running in background\nCtrl+Alt+Q: Quick edit\nCtrl+Alt+W: Voice record\nCtrl+Alt+E: Text-to-speech\nCtrl+Alt+C: Show clipboard\nCtrl+Alt+‚Üê/‚Üí/Num-/Num/: Navigate clipboard\nCustomize shortcuts in Settings!');

  if (!config.OPENAI_API_KEY) {
    console.log('‚ö†Ô∏è No OpenAI API key found in config');
    showPillNotification('Configuration Warning ‚Äì OpenAI API key not set. Voice and edit features will not work.');
  } else {
    console.log('‚úÖ OpenAI API key found in config');
  }

  // Initialize shortcuts manager
  console.log('‚å®Ô∏è Initializing shortcuts manager...');
  shortcutsManager = new ShortcutsManager();
  
  // Define all shortcut handlers
  const shortcutHandlers = {
    'quick-edit': handleQuickEdit,
    'voice-record': handleVoiceRecord,
    'text-to-speech': handleTextToSpeech,
    'clipboard-show': handleShowClipboard,
    'clipboard-next': handleClipboardNext,
    'clipboard-previous': handleClipboardPrevious,
    'clipboard-next-alt1': handleClipboardNext,
    'clipboard-previous-alt1': handleClipboardPrevious,
    'clipboard-next-alt2': handleClipboardNext,
    'clipboard-previous-alt2': handleClipboardPrevious,
    'spells-analysis': async () => {
      const clipboardContent = clipboard.readText();
      const spells = pythonSpellCaster.getSpellBook().filter(s => s.category === 'analysis');
      if (spells.length > 0) {
        await pythonSpellCaster.castSpell(spells[0].id, clipboardContent);
      }
    },
    'spells-data': async () => {
      const clipboardContent = clipboard.readText();
      const spells = pythonSpellCaster.getSpellBook().filter(s => s.category === 'data');
      if (spells.length > 0) {
        await pythonSpellCaster.castSpell(spells[0].id, clipboardContent);
      }
    },
    'spells-text': async () => {
      const clipboardContent = clipboard.readText();
      const spells = pythonSpellCaster.getSpellBook().filter(s => s.category === 'text');
      if (spells.length > 0) {
        await pythonSpellCaster.castSpell(spells[0].id, clipboardContent);
      }
    },
    // Quick spell slots
    'spell-slot-1': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        await pythonSpellCaster.castQuickSpell(1, clipboardContent);
      } catch (error) {
        console.warn('‚ö†Ô∏è Quick spell slot 1:', (error as Error).message);
        showPillNotification('No spell assigned to slot 1');
      }
    },
    'spell-slot-2': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        await pythonSpellCaster.castQuickSpell(2, clipboardContent);
      } catch (error) {
        console.warn('‚ö†Ô∏è Quick spell slot 2:', (error as Error).message);
        showPillNotification('No spell assigned to slot 2');
      }
    },
    'spell-slot-3': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        await pythonSpellCaster.castQuickSpell(3, clipboardContent);
      } catch (error) {
        console.warn('‚ö†Ô∏è Quick spell slot 3:', (error as Error).message);
        showPillNotification('No spell assigned to slot 3');
      }
    },
    'spell-slot-4': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        await pythonSpellCaster.castQuickSpell(4, clipboardContent);
      } catch (error) {
        console.warn('‚ö†Ô∏è Quick spell slot 4:', (error as Error).message);
        showPillNotification('No spell assigned to slot 4');
      }
    },
    'spell-slot-5': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        await pythonSpellCaster.castQuickSpell(5, clipboardContent);
      } catch (error) {
        console.warn('‚ö†Ô∏è Quick spell slot 5:', (error as Error).message);
        showPillNotification('No spell assigned to slot 5');
      }
    },
    'spell-slot-6': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        await pythonSpellCaster.castQuickSpell(6, clipboardContent);
      } catch (error) {
        console.warn('‚ö†Ô∏è Quick spell slot 6:', (error as Error).message);
        showPillNotification('No spell assigned to slot 6');
      }
    },
    'spell-slot-7': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        await pythonSpellCaster.castQuickSpell(7, clipboardContent);
      } catch (error) {
        console.warn('‚ö†Ô∏è Quick spell slot 7:', (error as Error).message);
        showPillNotification('No spell assigned to slot 7');
      }
    },
    'spell-slot-8': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        await pythonSpellCaster.castQuickSpell(8, clipboardContent);
      } catch (error) {
        console.warn('‚ö†Ô∏è Quick spell slot 8:', (error as Error).message);
        showPillNotification('No spell assigned to slot 8');
      }
    },
    'spell-slot-9': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        await pythonSpellCaster.castQuickSpell(9, clipboardContent);
      } catch (error) {
        console.warn('‚ö†Ô∏è Quick spell slot 9:', (error as Error).message);
        showPillNotification('No spell assigned to slot 9');
      }
    },
  };
  
  await shortcutsManager.initialize(shortcutHandlers);

  // Add IPC listener for update-clipboard
  ipcMain.on('update-clipboard', (event, text) => {
    console.log('üìã Received update-clipboard event:', text);
    clipboard.writeText(text);
    showPastille();
  });

  // Add IPC listener for update-clipboard-draft (real-time editing)
  ipcMain.on('update-clipboard-draft', (event, text) => {
    console.log('üìù Received update-clipboard-draft event:', text.substring(0, 50) + '...');
    clipboard.writeText(text);
    // Don't show pastille for draft updates to avoid interrupting editing
  });

  // Add IPC listener for expand-pastille
  ipcMain.on('expand-pastille', () => {
    if (pastilleWindow) {
      const { width: screenWidth, height: screenHeight } = screen.getPrimaryDisplay().workAreaSize;
      const targetWidth = Math.round(screenWidth * 0.7);
      const targetHeight = Math.round(screenHeight * 0.6);
      pastilleWindow.setAlwaysOnTop(true);
      pastilleWindow.setSize(targetWidth, targetHeight, true);
      pastilleWindow.center();
    }
  });

  // Add IPC listener for collapse-pastille
  ipcMain.on('collapse-pastille', () => {
    if (pastilleWindow) {
      pastilleWindow.setSize(500, 70, true);
      pastilleWindow.setAlwaysOnTop(false);
    }
  });

  // Add IPC listener for clipboard navigation from control bar
  ipcMain.on('clipboard-navigate', (event, direction) => {
    console.log('üîÑ Received clipboard-navigate event:', direction);
    if (direction === 'next') {
      handleClipboardNext();
    } else if (direction === 'previous') {
      handleClipboardPrevious();
    }
  });

  // Add IPC listener for opening settings
  ipcMain.on('open-settings', () => {
    console.log('‚öôÔ∏è Opening settings window...');
    openSettingsWindow();
  });

  // Add IPC listener for opening spell book
  ipcMain.on('open-spell-book', () => {
    console.log('üßô‚Äç‚ôÇÔ∏è Opening spell book window...');
    openSpellBookWindow();
  });

  // Add IPC listeners for settings management
  ipcMain.on('load-settings', (event) => {
    console.log('üìã Loading settings for dashboard...');
    const settings = {
      OPENAI_API_KEY: config.OPENAI_API_KEY || '',
      WHISPER_MODEL: config.WHISPER_MODEL,
      TTS_VOICE: config.TTS_VOICE
    };
    event.reply('settings-loaded', settings);
  });

  ipcMain.on('save-settings', (event, newSettings) => {
    console.log('üíæ Saving settings from dashboard...');
    try {
      // Update config object (note: this only updates runtime, not persistent storage)
      config.OPENAI_API_KEY = newSettings.OPENAI_API_KEY;
      config.WHISPER_MODEL = newSettings.WHISPER_MODEL;
      config.TTS_VOICE = newSettings.TTS_VOICE;
      
      console.log('‚úÖ Settings updated successfully');
      event.reply('settings-saved', true, 'Settings saved successfully!');
    } catch (error) {
      console.error('‚ùå Error saving settings:', error);
      event.reply('settings-saved', false, 'Failed to save settings: ' + error.message);
    }
  });

  ipcMain.on('validate-api-key', async (event, apiKey) => {
    console.log('üîç Validating API key...');
    try {
      // Simple validation - try to make a basic API call with timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000);
      
      const response = await fetch('https://api.openai.com/v1/models', {
        headers: {
          'Authorization': `Bearer ${apiKey}`,
        },
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);
      const isValid = response.ok;
      console.log('üîë API key validation result:', isValid);
      event.reply('api-key-validated', isValid);
    } catch (error) {
      console.log('‚ùå API key validation failed:', error.message);
      event.reply('api-key-validated', false);
    }
  });

  ipcMain.on('test-voice', async (event, { voice, text }) => {
    console.log('üîä Testing voice from settings:', voice);
    try {
      const audioFilePath = await callTextToSpeechApi(text, voice);
      if (audioFilePath && audioPlayer) {
        await audioPlayer.play(audioFilePath);
      }
    } catch (error) {
      console.error('‚ùå Voice test error:', error);
    }
  });

  // Add IPC for environment variables
  ipcMain.handle('load-env', () => {
    return readEnvConfig();
  });

  ipcMain.handle('save-env', async (event, { env, llm, llms }) => {
    try {
      // Persist to disk (includes llms list)
      writeEnvConfig({ env, llm, llms });

      // Apply to current process env and config
      Object.entries(env).forEach(([k,v]) => process.env[k]=v as string);
      if (llm) process.env['METAKEYAI_LLM'] = llm;

      (config as any).ENV_VARS = env;
      (config as any).DEFAULT_LLM = llm;
      (config as any).LLM_LIST = llms;

      // Notify daemon
      const daemon = await PythonDaemon.getInstance();
      const res = await daemon.updateEnv({ ...env, METAKEYAI_LLM: llm });
      return { ok: res?.ok !== false, msg: res?.msg || '' };
    } catch (err) {
      return { ok: false, msg: (err as Error).message };
    }
  });
});

const openSettingsWindow = () => {
  // If settings window already exists, focus it
  if (settingsWindow) {
    settingsWindow.focus();
    return;
  }

  console.log('ü™ü Creating settings window...');
  settingsWindow = new BrowserWindow({
    width: 700,
    height: 900,
    minWidth: 600,
    minHeight: 700,
    title: 'MetaKeyAI Settings',
    icon: null, // You can add an icon here
    show: false,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false,
    },
  });

  settingsWindow.loadURL(SETTINGS_WINDOW_WEBPACK_ENTRY);

  settingsWindow.once('ready-to-show', () => {
    settingsWindow?.show();
    console.log('‚úÖ Settings window ready and shown');
  });

  settingsWindow.on('closed', () => {
    settingsWindow = null;
    console.log('üö™ Settings window closed');
  });
};

const openSpellBookWindow = () => {
  // If spell book window already exists, focus it
  if (spellBookWindow) {
    spellBookWindow.focus();
    return;
  }

  console.log('ü™ü Creating spell book window...');
  spellBookWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    minWidth: 800,
    minHeight: 600,
    title: 'Python Spell Book - MetaKeyAI',
    icon: null,
    show: false,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false,
    },
  });

  // Load the spell book HTML file
  spellBookWindow.loadURL(SPELL_BOOK_WINDOW_WEBPACK_ENTRY);

  spellBookWindow.once('ready-to-show', () => {
    spellBookWindow?.show();
    console.log('‚úÖ Spell book window ready and shown');
  });

  spellBookWindow.on('closed', () => {
    spellBookWindow = null;
    console.log('üö™ Spell book window closed');
  });
};

// Since there are no windows, we don't need to handle 'window-all-closed'
// The app will continue running in the background.

app.on('will-quit', () => {
  // Cleanup shortcuts manager
  if (shortcutsManager) {
    shortcutsManager.cleanup();
    shortcutsManager = null;
  }
  
  // Cleanup clipboard history
  if (clipboardHistory) {
    clipboardHistory.destroy();
    clipboardHistory = null;
  }
  
  // Cleanup audio player
  if (audioPlayer) {
    audioPlayer.stop();
    audioPlayer = null;
  }
  
  // Cleanup Python Spell Caster
  pythonSpellCaster.cleanup();
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

/**
 * Shows a pill-style notification instead of the system notification.
 * Positions it near the bottom-right of the primary display.
 */
const showPillNotification = (message: string) => {
  if (!pastilleWindow) {
    console.warn('Pastille window not ready, cannot show pill notification');
    return;
  }

  const { width: screenWidth, height: screenHeight } = screen.getPrimaryDisplay().workAreaSize;

  const x = screenWidth - 500; // leave some margin
  const y = screenHeight - 100;

  pastilleWindow.setPosition(x, y);
  pastilleWindow.webContents.send('show-message', message);
  pastilleWindow.show();
};
