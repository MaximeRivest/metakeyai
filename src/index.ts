import { app, Tray, Menu, globalShortcut, clipboard, nativeImage, BrowserWindow, screen, ipcMain, dialog, shell } from 'electron';
import * as path from 'path';
import { callWhisperApi, callTextToSpeechApi } from './openai-api';
import { callDaemonQuickEdit } from './python-daemon-api';
import { config } from './config';
import { AudioRecorder } from './audio-recorder';
import { ClipboardHistory } from './clipboard-history';
import { AudioPlayer } from './audio-player';
import { PythonSpellCaster, pythonSpellCaster } from './python-spells';
import { ShortcutsManager } from './shortcuts-manager';
import { PythonDaemon } from './python-daemon';
import { PythonRunner } from './python-runner';
import { PythonSpell } from './python-spells';
import { UserDataManager } from './user-data-manager';
import * as fs from 'fs';

// This allows TypeScript to pick up the magic constants that are auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code.
// We don't have a window anymore, but we'll keep these for potential future use.
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const VISUALIZER_WINDOW_WEBPACK_ENTRY: string;
declare const VISUALIZER_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const PASTILLE_WINDOW_WEBPACK_ENTRY: string;
declare const PASTILLE_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const SETTINGS_WINDOW_WEBPACK_ENTRY: string;
declare const SETTINGS_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const SPELL_BOOK_WINDOW_WEBPACK_ENTRY: string;
declare const SPELL_BOOK_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

let tray: Tray | null = null;
let recorder: AudioRecorder | null = null;
let visualizerWindow: null = null;
let pastilleWindow: BrowserWindow | null = null;
let settingsWindow: BrowserWindow | null = null;
let spellBookWindow: BrowserWindow | null = null;
let clipboardHistory: ClipboardHistory | null = null;
let audioPlayer: AudioPlayer | null = null;
let shortcutsManager: ShortcutsManager | null = null;
let userDataManager: UserDataManager | null = null;
let spellCaster: PythonSpellCaster | null = null;

// Persistent env config path and helpers
const ENV_CONFIG_PATH = path.join(app.getPath('userData'), 'env_config.json');

interface EnvConfigFile { env: Record<string,string>; llm: string; llms?: string[]; }

function readEnvConfig(): EnvConfigFile {
  try {
    if (fs.existsSync(ENV_CONFIG_PATH)) {
      return JSON.parse(fs.readFileSync(ENV_CONFIG_PATH, 'utf-8')) as EnvConfigFile;
    }
  } catch {}
  return { env: {}, llm: '', llms: [] };
}

function writeEnvConfig(data: EnvConfigFile) {
  try {
    fs.mkdirSync(path.dirname(ENV_CONFIG_PATH), { recursive: true });
    fs.writeFileSync(ENV_CONFIG_PATH, JSON.stringify(data, null, 2), 'utf-8');
  } catch (err) {
    console.error('❌ Failed to persist env config', err);
  }
}

// Windows debugging setup
if (process.platform === 'win32') {
  // Always enable console for Windows debugging (both dev and production)
  try {
    const { exec } = require('child_process');
    
    // Allocate console window for debugging
    if (!app.isPackaged) {
      // Development: spawn a separate console window
      exec('start "MetaKeyAI Debug Console" cmd /k "echo MetaKeyAI Debug Console Started & echo Press Ctrl+C to close"', { detached: true });
    } else {
      // Production: try to allocate console to current process
      try {
        const kernel32 = require('ffi-napi').Library('kernel32', {
          'AllocConsole': ['bool', []],
          'FreeConsole': ['bool', []]
        });
        kernel32.AllocConsole();
        console.log('✅ Console allocated for Windows debugging');
      } catch (ffiError) {
        // Fallback: create a debug window
        console.log('⚠️ FFI not available, using fallback debug method');
      }
    }
  } catch (error) {
    console.log('Could not allocate debug console:', error);
  }
}

// Enhanced logging for Windows
// Save original console methods first to prevent recursion
const originalConsoleLog = console.log;
const originalConsoleError = console.error;

class WindowsLogger {
  private logFile: string;
  private debugMode: boolean;
  
  constructor() {
    this.debugMode = process.platform === 'win32';
    
    const logDir = app.isPackaged ? 
      path.join(process.env.APPDATA || '', 'MetaKeyAI', 'logs') : 
      path.join(process.cwd(), 'logs');
    
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }
    
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    this.logFile = path.join(logDir, `metakeyai-${timestamp}.log`);
    
    // Use this.log, which now correctly uses originalConsoleLog
    this.log('🚀 MetaKeyAI Debug Logger Started');
    this.log(`📍 Platform: ${process.platform} ${process.arch}`);
    this.log(`📦 Packaged: ${app.isPackaged}`);
    this.log(`📂 Log file: ${this.logFile}`);
    this.log(`🔧 Node version: ${process.version}`);
    this.log(`⚡ Electron version: ${process.versions.electron}`);
    this.log(`🏠 App path: ${app.getAppPath()}`);
    this.log(`💾 User data: ${app.getPath('userData')}`);
    
    if (process.platform === 'win32') {
      this.log(`🪟 Windows version: ${require('os').release()}`);
      this.log(`🎯 Resources path: ${process.resourcesPath || 'N/A'}`);
    }
  }
  
  private writeToFile(logEntry: string) {
    try {
      fs.appendFileSync(this.logFile, logEntry);
    } catch (error) {
      originalConsoleError('Failed to write to log file:', error);
    }
  }

  log(message: string) {
    const timestamp = new Date().toISOString();
    const logEntry = `[${timestamp}] ${message}\n`;
    
    // Always log to console using original function
    originalConsoleLog(message);
    
    // Also log to file
    this.writeToFile(logEntry);
  }
  
  error(message: string, error?: any) {
    const errorMsg = error ? `${message}: ${error.message || error}` : message;
    const fullMessage = `❌ ERROR: ${errorMsg}`;

    const timestamp = new Date().toISOString();
    const logEntry = `[${timestamp}] ${fullMessage}\n`;
    
    // Log to original console
    originalConsoleError(fullMessage);
    
    // Also log to file
    this.writeToFile(logEntry);

    if (error?.stack) {
      const stackLogEntry = `[${timestamp}] 📍 Stack: ${error.stack}\n`;
      originalConsoleError(`📍 Stack: ${error.stack}`);
      this.writeToFile(stackLogEntry);
    }
    
    // For Windows, also try to show a notification
    if (this.debugMode && app.isPackaged) {
      try {
        const { Notification } = require('electron');
        if (Notification.isSupported()) {
          new Notification({
            title: 'MetaKeyAI Error',
            body: errorMsg.substring(0, 100) + (errorMsg.length > 100 ? '...' : ''),
            urgency: 'critical'
          }).show();
        }
      } catch (notifError) {
        // Ignore notification errors
      }
    }
  }
  
  debug(message: string) {
    if (this.debugMode) {
      this.log(`🐛 DEBUG: ${message}`);
    }
  }
  
  getLogPath(): string {
    return this.logFile;
  }
  
  getLogDirectory(): string {
    return path.dirname(this.logFile);
  }
}

const logger = new WindowsLogger();

// Override console methods to use our logger
console.log = (...args) => {
  const message = args.map(arg => {
    if (typeof arg === 'object' && arg !== null) {
      try {
        return JSON.stringify(arg);
      } catch {
        return '[Unstringifiable Object]';
      }
    }
    return String(arg);
  }).join(' ');
  logger.log(message);
};

console.error = (...args) => {
  const errorInstance = args.find(arg => arg instanceof Error);
  const message = args
    .filter(arg => !(arg instanceof Error))
    .map(arg => {
      if (typeof arg === 'object' && arg !== null) {
        try {
          return JSON.stringify(arg);
        } catch {
          return '[Unstringifiable Object]';
        }
      }
      return String(arg);
    }).join(' ');
  
  logger.error(message, errorInstance);
};

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

const handleClipboardNext = () => {
  console.log('➡️ handleClipboardNext triggered!');
  if (!clipboardHistory) return;
  
  const entry = clipboardHistory.cycleNext();
  showPastille(); // Always show pastille to see current state
  if (entry) {
    console.log('📋 Next clipboard entry:', entry.text.substring(0, 50) + '...');
  }
};

const handleClipboardPrevious = () => {
  console.log('⬅️ handleClipboardPrevious triggered!');
  if (!clipboardHistory) return;
  
  const entry = clipboardHistory.cyclePrevious();
  showPastille(); // Always show pastille to see current state
  if (entry) {
    console.log('📋 Previous clipboard entry:', entry.text.substring(0, 50) + '...');
  }
};

const handleShowClipboard = () => {
  console.log('👁️ handleShowClipboard triggered!');
  showPastille(); // Show current clipboard state
};

const showPastille = () => {
  if (!pastilleWindow || !clipboardHistory) return;
  
  const currentEntry = clipboardHistory.getCurrentEntry();
  const currentIndex = clipboardHistory.getCurrentIndex();
  const totalCount = clipboardHistory.getHistoryLength();
  
  // Get fresh cursor position each time
  const cursorPosition = screen.getCursorScreenPoint();
  const { width: screenWidth, height: screenHeight } = screen.getPrimaryDisplay().workAreaSize;
  
  // Calculate position with bounds checking
  let x = cursorPosition.x + 20;
  let y = cursorPosition.y - 60;
  
  // Keep pastille on screen
  if (x + 520 > screenWidth) {
    x = cursorPosition.x - 540; // Show to the left of cursor
  }
  if (y < 0) {
    y = cursorPosition.y + 20; // Show below cursor
  }
  
  console.log('🖱️ Cursor position:', cursorPosition, '-> Pastille position:', { x, y });
  
  pastilleWindow.setPosition(x, y);
  
  pastilleWindow.webContents.send('clipboard-updated', {
    entry: currentEntry,
    currentIndex: currentIndex,
    totalCount: totalCount
  });
  
  pastilleWindow.webContents.send('show-pastille');
  pastilleWindow.show(); // Make sure the window is shown
  console.log('👁️ Pastille window shown at cursor position');
};

// Utility to position pill near current cursor
const positionPillNearCursor = () => {
  if (!pastilleWindow) return;
  const cursorPosition = screen.getCursorScreenPoint();
  const { width: screenWidth, height: screenHeight } = screen.getPrimaryDisplay().workAreaSize;
  let x = cursorPosition.x + 20;
  let y = cursorPosition.y - 80;
  if (x + 520 > screenWidth) x = cursorPosition.x - 540;
  if (y < 0) y = cursorPosition.y + 20;
  pastilleWindow.setPosition(x, y);
};

const handleQuickEdit = async () => {
  console.log('🚀 handleQuickEdit triggered!');
  const text = clipboard.readText();
  console.log('📋 Clipboard text:', text ? `"${text}"` : 'EMPTY');
  if (!text) {
    console.log('❌ No text in clipboard');
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', 'Quick Edit – No text in clipboard!');
    pastilleWindow?.show();
    return;
  }

  console.log('⏳ Starting Quick Edit processing...');
  positionPillNearCursor();
  pastilleWindow?.webContents.send('show-processing', 'Processing');
  pastilleWindow?.show();

  // First try Python daemon quick edit
  let response: string | null = null;
  try {
    response = await callDaemonQuickEdit(text);
    console.log('🐍 Daemon quick edit response:', response ? `"${response}"` : 'NULL');
  } catch (err) {
    console.error('🐍 Daemon quick edit error:', (err as Error).message);
  }

  console.log('📝 Quick Edit response:', response ? `"${response}"` : 'NULL');

  if (response) {
    clipboard.writeText(response);
    console.log('✅ Text processed and copied to clipboard');
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', response);
    pastilleWindow?.show();
  } else {
    console.log('❌ Failed to process text');
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', 'Quick Edit – Failed to process text!');
    pastilleWindow?.show();
  }
};

const processRecording = async (filePath: string) => {
  try {
    console.log(`🔄 Processing recording from ${filePath}`);
    const transcript = await callWhisperApi(filePath);
    console.log('📝 Whisper transcript:', transcript ? `"${transcript}"` : 'NULL');

    if (transcript) {
      // Save transcript to a file next to the recording
      const transcriptPath = filePath.replace('.wav', '.txt');
      fs.writeFileSync(transcriptPath, transcript);
      
      // Copy to clipboard
      clipboard.writeText(transcript);
      
      console.log(`💾 Transcript saved to ${transcriptPath} and copied to clipboard`);
      positionPillNearCursor();
      pastilleWindow?.webContents.send('show-message', transcript);
      pastilleWindow?.show();
    } else {
      console.log('❌ Failed to transcribe audio');
      positionPillNearCursor();
      pastilleWindow?.webContents.send('show-message', 'Failed to transcribe audio.');
      pastilleWindow?.show();
    }
  } catch (e) {
    console.error('❌ Error processing recording:', e);
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', `Error – Failed to process recording: ${e.message}`);
    pastilleWindow?.show();
  } finally {
    // Clean up the recording file
    // fs.unlink(filePath, (err) => {
    //   if (err) console.error(`Failed to delete audio file: ${filePath}`, err);
    //   else console.log(`Deleted audio file: ${filePath}`);
    // });
  }
};

const handleVoiceRecord = async () => {
  console.log('🎤 handleVoiceRecord triggered!');
  if (recorder && recorder.isRecording) {
    console.log('🛑 Stopping recording...');
    recorder.stop();
    // Visualizer merged into pastille – no separate window needed
    // stop showing waveform; pastille will switch to processing
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-processing', 'Processing');
    pastilleWindow?.show();
  } else {
    console.log('🎙️ Starting recording...');
    
    try {
      recorder = new AudioRecorder();

      // Set up event handlers before starting
      recorder.on('audio-data', (data: Buffer) => {
        pastilleWindow?.webContents.send('audio-data', data);
      });

      recorder.on('finished', (filePath: string) => {
        console.log('✅ Recording finished, file:', filePath);
        processRecording(filePath);
        recorder = null; // Reset recorder
      });

      recorder.on('error', (error: any) => {
        console.log('❌ Recording error:', error);
        
        let userMessage = 'Recording Error';
        let actionButton = '';
        
        // Provide user-friendly error messages based on the error
        if (error.message.includes('Malformed dshow input string') || 
            error.message.includes('I/O error') ||
            error.message.includes('Could not access the microphone')) {
          userMessage = 'Microphone access failed. The device may be in use or disconnected.';
          actionButton = '⚙️ Configure Audio Device';
        } else if (error.message.includes('No working audio device found')) {
          userMessage = 'No working microphone found. Please check your audio settings.';
          actionButton = '⚙️ Open Audio Settings';
        } else if (error.message.includes('Command failed')) {
          userMessage = 'Audio recording software issue. Try restarting the app.';
          actionButton = '🔄 Restart App';
        } else {
          userMessage = `Recording Error: ${error.message}`;
          actionButton = '⚙️ Audio Settings';
        }
        
        positionPillNearCursor();
        pastilleWindow?.webContents.send('show-message', userMessage);
        pastilleWindow?.show();
        
        // Show a more detailed dialog with action button
        setTimeout(() => {
          dialog.showMessageBox({
            type: 'warning',
            title: 'Audio Recording Issue',
            message: userMessage,
            detail: 'Would you like to configure your audio device settings?',
            buttons: ['Configure Audio Settings', 'Cancel'],
            defaultId: 0
          }).then(result => {
            if (result.response === 0) {
              // Open settings window with focus on audio section
              openSettingsWindow();
            }
          });
        }, 2000);
        
        recorder = null; // Reset recorder
      });

      // Check if recording is available before attempting to start
      const isAvailable = await recorder.isRecordingAvailable();
      if (!isAvailable) {
        console.log('❌ No recording method available');
        positionPillNearCursor();
        pastilleWindow?.webContents.send('show-message', 'Audio recording not available. Please run: npm run setup-audio');
        pastilleWindow?.show();
        recorder = null;
        return;
      }

      console.log('🔧 Recording method:', recorder.getRecordingMethod());

      // Start recording (now async)
      await recorder.start();

      // Tell pastille to enter recording mode with waveform
      positionPillNearCursor();
      pastilleWindow?.webContents.send('start-recording', 'Recording... Press Ctrl+Alt+W to stop.');
      pastilleWindow?.show();

    } catch (error) {
      console.error('❌ Failed to start recording:', error);
      positionPillNearCursor();
      pastilleWindow?.webContents.send('show-message', `Recording Setup Error – ${error.message}`);
      pastilleWindow?.show();
      recorder = null;
    }
  }
};

const handleTextToSpeech = async () => {
  console.log('🔊 handleTextToSpeech triggered!');
  if (!config.OPENAI_API_KEY) {
    console.log('❌ No OpenAI API key found');
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', 'Configuration Error: OpenAI API key is not set.');
    pastilleWindow?.show();
    return;
  }

  const text = clipboard.readText();
  console.log('📋 Clipboard text for TTS:', text ? `"${text.substring(0, 100)}..."` : 'EMPTY');
  
  if (!text) {
    console.log('❌ No text in clipboard');
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', 'Text-to-Speech – No text in clipboard!');
    pastilleWindow?.show();
    return;
  }

  // Stop any currently playing audio
  if (audioPlayer && audioPlayer.playing) {
    console.log('🛑 Stopping current audio playback');
    audioPlayer.stop();
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', 'Audio playback stopped.');
    pastilleWindow?.show();
    return;
  }

  console.log('⏳ Starting TTS processing...');
  positionPillNearCursor();
  pastilleWindow?.webContents.send('show-processing', 'Generating speech');
  pastilleWindow?.show();

  try {
    const audioFilePath = await callTextToSpeechApi(text, config.TTS_VOICE);
    console.log('🎵 TTS response:', audioFilePath ? `"${audioFilePath}"` : 'NULL');

    if (audioFilePath) {
      console.log('🔊 Starting audio playback...');
      positionPillNearCursor();
      pastilleWindow?.webContents.send('show-message', '🔊 Playing audio... (Ctrl+Alt+E to stop)');
      pastilleWindow?.show();

      // Initialize audio player if needed
      if (!audioPlayer) {
        audioPlayer = new AudioPlayer();
        
        audioPlayer.on('finished', () => {
          console.log('✅ Audio playback finished');
          positionPillNearCursor();
          pastilleWindow?.webContents.send('show-message', 'Audio playback completed.');
          pastilleWindow?.show();
          
          // Clean up the temporary file
          setTimeout(() => {
            if (fs.existsSync(audioFilePath)) {
              fs.unlinkSync(audioFilePath);
              console.log('🗑️ Cleaned up temporary audio file');
            }
          }, 1000);
        });

        audioPlayer.on('error', (error) => {
          console.error('❌ Audio playback error:', error);
          positionPillNearCursor();
          pastilleWindow?.webContents.send('show-message', `Audio Error – ${error.message}`);
          pastilleWindow?.show();
        });

        audioPlayer.on('stopped', () => {
          console.log('🛑 Audio playback stopped');
        });
      }

      await audioPlayer.play(audioFilePath);
    } else {
      console.log('❌ Failed to generate speech');
      positionPillNearCursor();
      pastilleWindow?.webContents.send('show-message', 'Text-to-Speech – Failed to generate audio!');
      pastilleWindow?.show();
    }
  } catch (error) {
    console.error('❌ TTS error:', error);
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', `TTS Error – ${error.message}`);
    pastilleWindow?.show();
  }
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', async () => {
  console.log('🚀 MetaKeyAI starting up...');
  
  // Create debug menu for Windows
  createDebugMenu();
  
  // Initialize components
  await initializeApp();
});

const openSettingsWindow = () => {
  // If settings window already exists, focus it
  if (settingsWindow) {
    settingsWindow.focus();
    return;
  }

  console.log('🪟 Creating settings window...');
  settingsWindow = new BrowserWindow({
    width: 700,
    height: 900,
    minWidth: 600,
    minHeight: 700,
    title: 'MetaKeyAI Settings',
    icon: null, // You can add an icon here
    show: false,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false,
    },
  });

  settingsWindow.loadURL(SETTINGS_WINDOW_WEBPACK_ENTRY);

  settingsWindow.once('ready-to-show', () => {
    settingsWindow?.show();
    console.log('✅ Settings window ready and shown');
  });

  settingsWindow.on('closed', () => {
    settingsWindow = null;
    console.log('🚪 Settings window closed');
  });
};

const openSpellBookWindow = () => {
  // If spell book window already exists, focus it
  if (spellBookWindow) {
    spellBookWindow.focus();
    return;
  }

  console.log('🪟 Creating spell book window...');
  spellBookWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    minWidth: 800,
    minHeight: 600,
    title: 'Python Spell Book - MetaKeyAI',
    icon: null,
    show: false,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false,
    },
  });

  // Load the spell book HTML file
  spellBookWindow.loadURL(SPELL_BOOK_WINDOW_WEBPACK_ENTRY);

  spellBookWindow.once('ready-to-show', () => {
    spellBookWindow?.show();
    console.log('✅ Spell book window ready and shown');
  });

  spellBookWindow.on('closed', () => {
    spellBookWindow = null;
    console.log('🚪 Spell book window closed');
  });
};

// Since there are no windows, we don't need to handle 'window-all-closed'
// The app will continue running in the background.

app.on('will-quit', () => {
  // Cleanup shortcuts manager
  if (shortcutsManager) {
    shortcutsManager.cleanup();
    shortcutsManager = null;
  }
  
  // Cleanup clipboard history
  if (clipboardHistory) {
    clipboardHistory.destroy();
    clipboardHistory = null;
  }
  
  // Cleanup audio player
  if (audioPlayer) {
    audioPlayer.stop();
    audioPlayer = null;
  }
  
  // Cleanup Python Spell Caster
  spellCaster?.cleanup();
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

/**
 * Shows a pill-style notification instead of the system notification.
 * Positions it near the bottom-right of the primary display.
 */
const showPillNotification = (message: string) => {
  if (!pastilleWindow) {
    console.warn('Pastille window not ready, cannot show pill notification');
    return;
  }

  const { width: screenWidth, height: screenHeight } = screen.getPrimaryDisplay().workAreaSize;

  const x = screenWidth - 500; // leave some margin
  const y = screenHeight - 100;

  pastilleWindow.setPosition(x, y);
  pastilleWindow.webContents.send('show-message', message);
  pastilleWindow.show();
};

// Add debug menu for Windows
function createDebugMenu() {
  if (process.platform === 'win32') {
    const { Menu } = require('electron');
    
    const debugMenu = Menu.buildFromTemplate([
      {
        label: 'Debug',
        submenu: [
          {
            label: 'Open Log File',
            click: () => {
              shell.openPath(logger.getLogPath());
            }
          },
          {
            label: 'Open Log Directory',
            click: () => {
              shell.showItemInFolder(logger.getLogPath());
            }
          },
          {
            label: 'Show Debug Info',
            click: () => {
              const info = {
                platform: process.platform,
                arch: process.arch,
                version: app.getVersion(),
                packaged: app.isPackaged,
                logFile: logger.getLogPath(),
                appData: app.getPath('appData'),
                userData: app.getPath('userData'),
                resourcesPath: process.resourcesPath || 'N/A'
              };
              
              dialog.showMessageBox({
                type: 'info',
                title: 'Debug Information',
                message: 'MetaKeyAI Debug Info',
                detail: JSON.stringify(info, null, 2),
                buttons: ['Copy to Clipboard', 'OK']
              }).then((result) => {
                if (result.response === 0) {
                  clipboard.writeText(JSON.stringify(info, null, 2));
                }
              });
            }
          },
          {
            label: 'Test Audio Recording',
            click: async () => {
              try {
                logger.log('🎤 Testing audio recording...');
                const audioRecorder = new AudioRecorder();
                await audioRecorder.start();
                setTimeout(async () => {
                  const file = await audioRecorder.stop();
                  logger.log(`✅ Audio test completed: ${file}`);
                  dialog.showMessageBox({
                    type: 'info',
                    title: 'Audio Test',
                    message: `Audio recording test completed!\nFile: ${file}`,
                    buttons: ['OK']
                  });
                }, 2000);
              } catch (error) {
                logger.error('Audio test failed', error);
                dialog.showErrorBox('Audio Test Failed', error.message);
              }
            }
          },
          {
            label: 'Test Audio Playback',
            click: async () => {
              try {
                logger.log('🔊 Testing audio playback...');
                
                // Create a test audio file (simple beep)
                const testAudioPath = path.join(require('os').tmpdir(), 'test-beep.wav');
                
                // For now, just test with any existing audio file or show capabilities
                if (!audioPlayer) {
                  audioPlayer = new AudioPlayer();
                }
                
                // Test audio capabilities
                const capabilities = await testAudioCapabilities();
                
                dialog.showMessageBox({
                  type: 'info',
                  title: 'Audio Playback Test',
                  message: 'Audio Capabilities Test',
                  detail: JSON.stringify(capabilities, null, 2),
                  buttons: ['OK']
                });
                
              } catch (error) {
                logger.error('Audio playback test failed', error);
                dialog.showErrorBox('Audio Playback Test Failed', error.message);
              }
            }
          },
          {
            label: 'Generate Debug Report',
            click: async () => {
              try {
                const report = await generateDebugReport();
                const reportPath = path.join(logger.getLogDirectory(), `debug-report-${Date.now()}.json`);
                fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
                
                dialog.showMessageBox({
                  type: 'info',
                  title: 'Debug Report Generated',
                  message: `Debug report saved to:\n${reportPath}`,
                  buttons: ['Open Report', 'Open Folder', 'OK']
                }).then((result) => {
                  if (result.response === 0) {
                    shell.openPath(reportPath);
                  } else if (result.response === 1) {
                    shell.showItemInFolder(reportPath);
                  }
                });
              } catch (error) {
                logger.error('Failed to generate debug report', error);
                dialog.showErrorBox('Debug Report Failed', error.message);
              }
            }
          }
        ]
      }
    ]);
    
    Menu.setApplicationMenu(debugMenu);
  }
}

async function testAudioCapabilities() {
  const capabilities = {
    platform: process.platform,
    audioRecorderAvailable: false,
    audioPlayerAvailable: false,
    soxAvailable: false,
    ffmpegAvailable: false,
    powershellAvailable: false,
    windowsMediaPlayerAvailable: false,
    errors: [] as string[]
  };

  try {
    // Test audio recorder
    if (recorder) {
      capabilities.audioRecorderAvailable = true;
    }
  } catch (error: any) {
    capabilities.errors.push(`Audio recorder test failed: ${error.message}`);
  }

  try {
    // Test audio player
    if (audioPlayer) {
      capabilities.audioPlayerAvailable = true;
    }
  } catch (error: any) {
    capabilities.errors.push(`Audio player test failed: ${error.message}`);
  }

  // Test Sox availability
  try {
    const { spawn } = require('child_process');
    await new Promise((resolve, reject) => {
      const proc = spawn('sox', ['--version'], { stdio: 'pipe' });
      proc.on('close', (code: number) => {
        if (code === 0) {
          capabilities.soxAvailable = true;
          resolve(true);
        } else {
          reject(new Error(`Sox test failed with code ${code}`));
        }
      });
      proc.on('error', reject);
      setTimeout(() => {
        proc.kill();
        reject(new Error('Sox test timed out'));
      }, 3000);
    });
  } catch (error: any) {
    capabilities.errors.push(`Sox test failed: ${error.message}`);
  }

  // Test FFmpeg availability
  try {
    const { spawn } = require('child_process');
    await new Promise((resolve, reject) => {
      const proc = spawn('ffmpeg', ['-version'], { stdio: 'pipe' });
      proc.on('close', (code: number) => {
        if (code === 0) {
          capabilities.ffmpegAvailable = true;
          resolve(true);
        } else {
          reject(new Error(`FFmpeg test failed with code ${code}`));
        }
      });
      proc.on('error', reject);
      setTimeout(() => {
        proc.kill();
        reject(new Error('FFmpeg test timed out'));
      }, 3000);
    });
  } catch (error: any) {
    capabilities.errors.push(`FFmpeg test failed: ${error.message}`);
  }

  // Windows-specific tests
  if (process.platform === 'win32') {
    // Test PowerShell
    try {
      const { spawn } = require('child_process');
      await new Promise((resolve, reject) => {
        const proc = spawn('powershell', ['-Command', 'Write-Output "PowerShell available"'], { stdio: 'pipe' });
        proc.on('close', (code: number) => {
          if (code === 0) {
            capabilities.powershellAvailable = true;
            resolve(true);
          } else {
            reject(new Error(`PowerShell test failed with code ${code}`));
          }
        });
        proc.on('error', reject);
        setTimeout(() => {
          proc.kill();
          reject(new Error('PowerShell test timed out'));
        }, 3000);
      });
    } catch (error: any) {
      capabilities.errors.push(`PowerShell test failed: ${error.message}`);
    }

    // Test Windows Media Player
    const wmplayerPaths = [
      'C:\\Program Files\\Windows Media Player\\wmplayer.exe',
      'C:\\Program Files (x86)\\Windows Media Player\\wmplayer.exe'
    ];
    
    for (const wmplayerPath of wmplayerPaths) {
      if (fs.existsSync(wmplayerPath)) {
        capabilities.windowsMediaPlayerAvailable = true;
        break;
      }
    }
  }

  return capabilities;
}

async function generateDebugReport() {
  const report: any = {
    timestamp: new Date().toISOString(),
    system: {
      platform: process.platform,
      arch: process.arch,
      nodeVersion: process.version,
      electronVersion: process.versions.electron,
      appVersion: app.getVersion(),
      isPackaged: app.isPackaged,
      appPath: app.getAppPath(),
      userData: app.getPath('userData'),
      resourcesPath: process.resourcesPath || 'N/A'
    },
    audio: await testAudioCapabilities(),
    environment: {
      NODE_ENV: process.env.NODE_ENV,
      PATH: process.env.PATH,
      APPDATA: process.env.APPDATA,
      LOCALAPPDATA: process.env.LOCALAPPDATA,
      PROGRAMFILES: process.env.PROGRAMFILES,
      'PROGRAMFILES(X86)': process.env['PROGRAMFILES(X86)']
    },
    files: {
      logFile: logger.getLogPath(),
      logDirectory: logger.getLogDirectory(),
      configExists: fs.existsSync(ENV_CONFIG_PATH),
      configPath: ENV_CONFIG_PATH
    },
    components: {
      recorder: !!recorder,
      audioPlayer: !!audioPlayer,
      clipboardHistory: !!clipboardHistory,
      shortcutsManager: !!shortcutsManager,
      tray: !!tray
    }
  };

  // Add recent log entries
  try {
    const logContent = fs.readFileSync(logger.getLogPath(), 'utf-8');
    const logLines = logContent.split('\n').slice(-50); // Last 50 lines
    report.recentLogs = logLines.filter(line => line.trim());
  } catch (error: any) {
    report.recentLogs = [`Failed to read log file: ${error.message}`];
  }

  return report;
}

async function initializeApp() {
  console.log('📋 Initializing clipboard history...');
  clipboardHistory = new ClipboardHistory(50);
  
  clipboardHistory.on('history-updated', (entry) => {
    console.log('📋 Clipboard history updated:', entry?.text?.substring(0, 50) + '...');
  });
  
  clipboardHistory.on('current-changed', (entry) => {
    console.log('📋 Current clipboard entry changed:', entry?.text?.substring(0, 50) + '...');
  });
  
  console.log('✅ Clipboard history initialized');
  
  // Initialize Python Spell Caster
  console.log('🧙‍♂️ Initializing Python Spell Caster...');
  try {
    spellCaster = pythonSpellCaster; // Use the exported instance
    await spellCaster.initialize();
    console.log('✅ Python Spell Caster initialized');
  } catch (error) {
    console.error('❌ Failed to initialize Python Spell Caster:', error);
  }
  
  // Create the pastille window
  console.log('🪟 Creating pastille window...');
  pastilleWindow = new BrowserWindow({
    width: 500,
    height: 70,
    frame: false,
    transparent: true,
    alwaysOnTop: false,
    show: false,
    resizable: true,
    skipTaskbar: true,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false,
    },
  });

  pastilleWindow.loadURL(PASTILLE_WINDOW_WEBPACK_ENTRY);
  pastilleWindow.setIgnoreMouseEvents(false);
  
  // Initialize pastille with current clipboard content once it's ready
  pastilleWindow.webContents.once('did-finish-load', () => {
    console.log('🎯 Pastille window loaded, initializing with current clipboard');
    setTimeout(() => {
      const currentEntry = clipboardHistory?.getCurrentEntry();
      const currentIndex = clipboardHistory?.getCurrentIndex() ?? -1;
      const totalCount = clipboardHistory?.getHistoryLength() ?? 0;
      
      pastilleWindow?.webContents.send('clipboard-updated', {
        entry: currentEntry,
        currentIndex: currentIndex,
        totalCount: totalCount
      });
    }, 100);
  });
  
  console.log('✅ Pastille window created');

  // Create tray icon
  console.log('🖼️ Creating tray icon...');
  const image = nativeImage.createFromDataURL(
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAEklEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='
  );
  tray = new Tray(image);
  
  const contextMenu = Menu.buildFromTemplate([
    { label: 'Exit', type: 'normal', click: () => app.quit() },
  ]);

  tray.setToolTip('MetaKeyAI');
  tray.setContextMenu(contextMenu);
  console.log('✅ Tray created');
  
  showPillNotification('MetaKeyAI running in background\nCtrl+Alt+Q: Quick edit\nCtrl+Alt+W: Voice record\nCtrl+Alt+E: Text-to-speech\nCtrl+Alt+C: Show clipboard\nCtrl+Alt+←/→/Num-/Num/: Navigate clipboard\nCustomize shortcuts in Settings!');

  if (!config.OPENAI_API_KEY) {
    console.log('⚠️ No OpenAI API key found in config');
    showPillNotification('Configuration Warning – OpenAI API key not set. Voice and edit features will not work.');
  } else {
    console.log('✅ OpenAI API key found in config');
  }

  // Initialize shortcuts manager (logging handled inside ShortcutsManager)
  shortcutsManager = ShortcutsManager.getInstance();
  
  // Define all shortcut handlers
  const shortcutHandlers = {
    'quick-edit': handleQuickEdit,
    'voice-record': handleVoiceRecord,
    'text-to-speech': handleTextToSpeech,
    'clipboard-show': handleShowClipboard,
    'clipboard-next': handleClipboardNext,
    'clipboard-previous': handleClipboardPrevious,
    'clipboard-next-alt1': handleClipboardNext,
    'clipboard-previous-alt1': handleClipboardPrevious,
    'clipboard-next-alt2': handleClipboardNext,
    'clipboard-previous-alt2': handleClipboardPrevious,
    'spells-analysis': async () => {
      const clipboardContent = clipboard.readText();
      const spells = spellCaster?.getSpellBook().filter((s: any) => s.category === 'analysis') || [];
      if (spells.length > 0) {
        await spellCaster?.castSpell(spells[0].id, clipboardContent);
      }
    },
    'spells-data': async () => {
      const clipboardContent = clipboard.readText();
      const spells = spellCaster?.getSpellBook().filter((s: any) => s.category === 'data') || [];
      if (spells.length > 0) {
        await spellCaster?.castSpell(spells[0].id, clipboardContent);
      }
    },
    'spells-text': async () => {
      const clipboardContent = clipboard.readText();
      const spells = spellCaster?.getSpellBook().filter((s: any) => s.category === 'text') || [];
      if (spells.length > 0) {
        await spellCaster?.castSpell(spells[0].id, clipboardContent);
      }
    },
    // Quick spell slots
    'spell-slot-1': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        await spellCaster?.castQuickSpell(1, clipboardContent);
      } catch (error) {
        console.warn('⚠️ Quick spell slot 1:', (error as Error).message);
        showPillNotification('No spell assigned to slot 1');
      }
    },
    'spell-slot-2': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        await spellCaster?.castQuickSpell(2, clipboardContent);
      } catch (error) {
        console.warn('⚠️ Quick spell slot 2:', (error as Error).message);
        showPillNotification('No spell assigned to slot 2');
      }
    },
    'spell-slot-3': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        await spellCaster?.castQuickSpell(3, clipboardContent);
      } catch (error) {
        console.warn('⚠️ Quick spell slot 3:', (error as Error).message);
        showPillNotification('No spell assigned to slot 3');
      }
    },
    'spell-slot-4': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        await spellCaster?.castQuickSpell(4, clipboardContent);
      } catch (error) {
        console.warn('⚠️ Quick spell slot 4:', (error as Error).message);
        showPillNotification('No spell assigned to slot 4');
      }
    },
    'spell-slot-5': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        await spellCaster?.castQuickSpell(5, clipboardContent);
      } catch (error) {
        console.warn('⚠️ Quick spell slot 5:', (error as Error).message);
        showPillNotification('No spell assigned to slot 5');
      }
    },
    'spell-slot-6': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        await spellCaster?.castQuickSpell(6, clipboardContent);
      } catch (error) {
        console.warn('⚠️ Quick spell slot 6:', (error as Error).message);
        showPillNotification('No spell assigned to slot 6');
      }
    },
    'spell-slot-7': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        await spellCaster?.castQuickSpell(7, clipboardContent);
      } catch (error) {
        console.warn('⚠️ Quick spell slot 7:', (error as Error).message);
        showPillNotification('No spell assigned to slot 7');
      }
    },
    'spell-slot-8': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        await spellCaster?.castQuickSpell(8, clipboardContent);
      } catch (error) {
        console.warn('⚠️ Quick spell slot 8:', (error as Error).message);
        showPillNotification('No spell assigned to slot 8');
      }
    },
    'spell-slot-9': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        await spellCaster?.castQuickSpell(9, clipboardContent);
      } catch (error) {
        console.warn('⚠️ Quick spell slot 9:', (error as Error).message);
        showPillNotification('No spell assigned to slot 9');
      }
    },
  };
  
  await shortcutsManager.initialize(shortcutHandlers);

  // Add IPC listeners
  setupIpcListeners();
}

function setupIpcListeners() {
  // Add IPC listener for update-clipboard
  ipcMain.on('update-clipboard', (event, text) => {
    console.log('📋 Received update-clipboard event:', text);
    clipboard.writeText(text);
    showPastille();
  });
  
  // Add IPC listener for update-clipboard-draft (real-time editing)
  ipcMain.on('update-clipboard-draft', (event, text) => {
    console.log('📝 Received update-clipboard-draft event:', text.substring(0, 50) + '...');
    clipboard.writeText(text);
    // Don't show pastille for draft updates to avoid interrupting editing
  });

  // Add IPC listener for expand-pastille
  ipcMain.on('expand-pastille', () => {
    if (pastilleWindow) {
      const { width: screenWidth, height: screenHeight } = screen.getPrimaryDisplay().workAreaSize;
      const targetWidth = Math.round(screenWidth * 0.7);
      const targetHeight = Math.round(screenHeight * 0.6);
      pastilleWindow.setAlwaysOnTop(true);
      pastilleWindow.setSize(targetWidth, targetHeight, true);
      pastilleWindow.center();
    }
  });

  // Add IPC listener for collapse-pastille
  ipcMain.on('collapse-pastille', () => {
    if (pastilleWindow) {
      pastilleWindow.setSize(500, 70, true);
      pastilleWindow.setAlwaysOnTop(false);
    }
  });

  // Add IPC listener for clipboard navigation from control bar
  ipcMain.on('clipboard-navigate', (event, direction) => {
    console.log('🔄 Received clipboard-navigate event:', direction);
    if (direction === 'next') {
      handleClipboardNext();
    } else if (direction === 'previous') {
      handleClipboardPrevious();
    }
  });

  // Add IPC listener for opening settings
  ipcMain.on('open-settings', () => {
    console.log('⚙️ Opening settings window...');
    openSettingsWindow();
  });

  // Add IPC listener for opening spell book
  ipcMain.on('open-spell-book', () => {
    console.log('🧙‍♂️ Opening spell book window...');
    openSpellBookWindow();
  });

  // Add IPC listeners for settings management
  ipcMain.on('load-settings', (event) => {
    console.log('📋 Loading settings for dashboard...');
    const settings = {
      OPENAI_API_KEY: config.OPENAI_API_KEY || '',
      WHISPER_MODEL: config.WHISPER_MODEL,
      TTS_VOICE: config.TTS_VOICE,
      MICROPHONE_DEVICE: recorder?.getUserAudioDevice() || 'auto'
    };
    event.reply('settings-loaded', settings);
  });

  ipcMain.on('save-settings', (event, newSettings) => {
    console.log('💾 Saving settings from dashboard...');
    try {
      // Update config object (note: this only updates runtime, not persistent storage)
      config.OPENAI_API_KEY = newSettings.OPENAI_API_KEY;
      config.WHISPER_MODEL = newSettings.WHISPER_MODEL;
      config.TTS_VOICE = newSettings.TTS_VOICE;
      
      // Update microphone device if provided
      if (newSettings.MICROPHONE_DEVICE !== undefined && recorder) {
        if (newSettings.MICROPHONE_DEVICE === 'auto') {
          recorder.setUserAudioDevice('');
        } else {
          recorder.setUserAudioDevice(newSettings.MICROPHONE_DEVICE);
        }
      }
      
      console.log('✅ Settings updated successfully');
      event.reply('settings-saved', true, 'Settings saved successfully!');
    } catch (error) {
      console.error('❌ Error saving settings:', error);
      event.reply('settings-saved', false, 'Failed to save settings: ' + (error as Error).message);
    }
  });

  ipcMain.on('validate-api-key', async (event, apiKey) => {
    console.log('🔍 Validating API key...');
    try {
      // Simple validation - try to make a basic API call with timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000);
      
      const response = await fetch('https://api.openai.com/v1/models', {
        headers: {
          'Authorization': `Bearer ${apiKey}`,
        },
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);
      const isValid = response.ok;
      console.log('🔑 API key validation result:', isValid);
      event.reply('api-key-validated', isValid);
    } catch (error) {
      console.log('❌ API key validation failed:', error.message);
      event.reply('api-key-validated', false);
    }
  });

  ipcMain.on('test-voice', async (event, { voice, text }) => {
    console.log('🔊 Testing voice from settings:', voice);
    try {
      const audioFilePath = await callTextToSpeechApi(text, voice);
      if (audioFilePath && audioPlayer) {
        await audioPlayer.play(audioFilePath);
      }
    } catch (error) {
      console.error('❌ Voice test error:', error);
    }
  });

  // Add IPC for environment variables
  ipcMain.handle('load-env', () => {
    return readEnvConfig();
  });

  ipcMain.handle('save-env', async (event, { env, llm, llms }) => {
    try {
      // Persist to disk (includes llms list)
      writeEnvConfig({ env, llm, llms });

      // Apply to current process env and config
      Object.entries(env).forEach(([k,v]) => process.env[k]=v as string);
      if (llm) process.env['METAKEYAI_LLM'] = llm;

      (config as any).ENV_VARS = env;
      (config as any).DEFAULT_LLM = llm;
      (config as any).LLM_LIST = llms;

      // Notify daemon
      const daemon = await PythonDaemon.getInstance();
      const res = await daemon.updateEnv({ ...env, METAKEYAI_LLM: llm });
      return { ok: res?.ok !== false, msg: res?.msg || '' };
    } catch (err) {
      return { ok: false, msg: (err as Error).message };
    }
  });

  // Microphone management IPC handlers
  ipcMain.on('discover-microphones', async (event) => {
    try {
      console.log('🎤 Discovering microphones...');
      
      // Create a temporary AudioRecorder instance for discovery
      const tempRecorder = new AudioRecorder();
      const audioInfo = await tempRecorder.getAudioDeviceInfo();
      
      console.log('🎤 Audio device info:', audioInfo);
      
      event.reply('microphones-discovered', audioInfo);
      event.reply('microphone-status', {
        status: audioInfo.needsConfiguration ? 'warning' : 'connected',
        message: audioInfo.needsConfiguration 
          ? 'Multiple microphones detected. Consider selecting a specific device.'
          : `Ready with ${audioInfo.currentRecordingMethod} method`
      });
    } catch (error) {
      console.error('❌ Error discovering microphones:', error);
      event.reply('microphone-status', {
        status: 'disconnected',
        message: `Error: ${(error as Error).message}`
      });
    }
  });

  ipcMain.on('set-microphone-device', (event, deviceName) => {
    try {
      console.log('🎤 Setting microphone device:', deviceName);
      
      if (recorder) {
        if (deviceName === 'auto') {
          // Clear user preference to use auto-detection
          recorder.setUserAudioDevice('');
        } else {
          // Set specific device
          recorder.setUserAudioDevice(deviceName);
        }
      }
    } catch (error) {
      console.error('❌ Error setting microphone device:', error);
    }
  });

  ipcMain.on('test-microphone', async (event, { device, duration = 3000 }) => {
    try {
      console.log('🎙️ Testing microphone:', device, 'for', duration, 'ms');
      
      // Create a test AudioRecorder instance
      const testRecorder = new AudioRecorder();
      
      // Set device if not auto
      if (device && device !== 'auto') {
        testRecorder.setUserAudioDevice(device);
      }
      
      let testResult = {
        success: false,
        error: '',
        duration: 0,
        method: '',
        fileSize: 0
      };
      
      // Set up event listeners for the test
      testRecorder.on('finished', (outputFile: string) => {
        try {
          const fs = require('fs');
          const stats = fs.statSync(outputFile);
          testResult = {
            success: true,
            error: '',
            duration: duration,
            method: testRecorder.getRecordingMethod(),
            fileSize: stats.size
          };
          
          // Clean up test file
          fs.unlinkSync(outputFile);
          
          event.reply('microphone-test-result', testResult);
        } catch (cleanupError) {
          console.error('❌ Error cleaning up test file:', cleanupError);
          event.reply('microphone-test-result', {
            success: true,
            error: '',
            duration: duration,
            method: testRecorder.getRecordingMethod(),
            fileSize: 0
          });
        }
      });
      
      testRecorder.on('error', (error: Error) => {
        testResult = {
          success: false,
          error: error.message,
          duration: 0,
          method: testRecorder.getRecordingMethod(),
          fileSize: 0
        };
        event.reply('microphone-test-result', testResult);
      });
      
      // Start the test recording
      await testRecorder.start();
      
      // Stop after specified duration
      setTimeout(() => {
        if (testRecorder.isRecording) {
          testRecorder.stop();
        }
      }, duration);
      
    } catch (error) {
      console.error('❌ Error testing microphone:', error);
      event.reply('microphone-test-result', {
        success: false,
        error: (error as Error).message,
        duration: 0,
        method: 'unknown',
        fileSize: 0
      });
    }
  });
}
