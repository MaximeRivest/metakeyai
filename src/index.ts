import { app, Tray, Menu, globalShortcut, clipboard, nativeImage, BrowserWindow, screen, ipcMain, dialog, shell, session } from 'electron';
import * as path from 'path';
import { tmpdir } from 'os';
import { callWhisperApi, callTextToSpeechApi } from './openai-api';
import { callDaemonQuickEdit } from './python-daemon-api';
import { config } from './config';
// Old audio recorder import removed - now using AudioManager
import { ClipboardHistory } from './clipboard-history';
import { AudioPlayer } from './audio-player';
import { PythonSpellCaster, pythonSpellCaster } from './python-spells';
import { ShortcutsManager } from './shortcuts-manager';
import { PythonDaemon } from './python-daemon';
import { PythonRunner } from './python-runner';
import { PythonSpell } from './python-spells';
import { UserDataManager } from './user-data-manager';
import { PythonSetupManager } from './python-setup-manager';
import { FirstRunManager } from './first-run-manager';
import { AudioManager } from './audio-manager';
import * as fs from 'fs';

// This allows TypeScript to pick up the magic constants that are auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code.
// We don't have a window anymore, but we'll keep these for potential future use.
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const VISUALIZER_WINDOW_WEBPACK_ENTRY: string;
declare const VISUALIZER_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const PASTILLE_WINDOW_WEBPACK_ENTRY: string;
declare const PASTILLE_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const SETTINGS_WINDOW_WEBPACK_ENTRY: string;
declare const SETTINGS_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const SPELL_BOOK_WINDOW_WEBPACK_ENTRY: string;
declare const SPELL_BOOK_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

let tray: Tray | null = null;
// Old recorder variable removed - now using AudioManager
let mainWindow: BrowserWindow | null = null;
let visualizerWindow: null = null;
let pastilleWindow: BrowserWindow | null = null;
let settingsWindow: BrowserWindow | null = null;
let spellBookWindow: BrowserWindow | null = null;
let clipboardHistory: ClipboardHistory | null = null;
let audioPlayer: AudioPlayer | null = null;
let shortcutsManager: ShortcutsManager | null = null;
let userDataManager: UserDataManager | null = null;
let spellCaster: PythonSpellCaster | null = null;
let firstRunManager: FirstRunManager | null = null;
let audioManager: AudioManager | null = null;

// Custom app property for quit handling
(app as any).isQuitting = false;

// Model configuration interface
interface EnvConfigFile { env: Record<string,string>; llm: string; llms?: string[]; }

// Legacy config path for migration
const LEGACY_ENV_CONFIG_PATH = path.join(app.getPath('userData'), 'env_config.json');

function readEnvConfig(): EnvConfigFile {
  try {
    if (!userDataManager) {
      userDataManager = UserDataManager.getInstance();
    }
    
    // Try to migrate from old location first
    if (fs.existsSync(LEGACY_ENV_CONFIG_PATH)) {
      const migrated = userDataManager.migrateOldModelConfig(LEGACY_ENV_CONFIG_PATH);
      if (migrated) {
        console.log('üîÑ Migrated model configuration to new location');
      }
    }
    
    // Load from new location
    const config = userDataManager.loadModelConfig();
    if (config) {
      return config;
    }
  } catch (error) {
    console.error('‚ùå Failed to load model config:', error);
  }
  return { env: {}, llm: '', llms: [] };
}

function writeEnvConfig(data: EnvConfigFile): void {
  try {
    if (!userDataManager) {
      userDataManager = UserDataManager.getInstance();
    }
    userDataManager.saveModelConfig(data);
  } catch (err) {
    console.error('‚ùå Failed to persist model config', err);
  }
}

// Windows debugging setup
if (process.platform === 'win32') {
  // Always enable console for Windows debugging (both dev and production)
  try {
    const { exec } = require('child_process');
    
    // Allocate console window for debugging
    if (!app.isPackaged) {
      // Development: spawn a separate console window
      exec('start "MetaKeyAI Debug Console" cmd /k "echo MetaKeyAI Debug Console Started & echo Press Ctrl+C to close"', { detached: true });
    } else {
      // Production: try to allocate console to current process
      try {
        const kernel32 = require('ffi-napi').Library('kernel32', {
          'AllocConsole': ['bool', []],
          'FreeConsole': ['bool', []]
        });
        kernel32.AllocConsole();
        console.log('‚úÖ Console allocated for Windows debugging');
      } catch (ffiError) {
        // Fallback: create a debug window
        console.log('‚ö†Ô∏è FFI not available, using fallback debug method');
      }
    }
  } catch (error) {
    console.log('Could not allocate debug console:', error);
  }
}

// Enhanced logging for Windows
// Save original console methods first to prevent recursion
const originalConsoleLog = console.log;
const originalConsoleError = console.error;

class WindowsLogger {
  private logFile: string;
  private debugMode: boolean;
  
  constructor() {
    this.debugMode = process.platform === 'win32';
    
    const logDir = app.isPackaged ? 
      path.join(process.env.APPDATA || '', 'MetaKeyAI', 'logs') : 
      path.join(process.cwd(), 'logs');
    
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }
    
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    this.logFile = path.join(logDir, `metakeyai-${timestamp}.log`);
    
    // Use this.log, which now correctly uses originalConsoleLog
    this.log('üöÄ MetaKeyAI Debug Logger Started');
    this.log(`üìç Platform: ${process.platform} ${process.arch}`);
    this.log(`üì¶ Packaged: ${app.isPackaged}`);
    this.log(`üìÇ Log file: ${this.logFile}`);
    this.log(`üîß Node version: ${process.version}`);
    this.log(`‚ö° Electron version: ${process.versions.electron}`);
    this.log(`üè† App path: ${app.getAppPath()}`);
    this.log(`üíæ User data: ${app.getPath('userData')}`);
    
    if (process.platform === 'win32') {
      this.log(`ü™ü Windows version: ${require('os').release()}`);
      this.log(`üéØ Resources path: ${process.resourcesPath || 'N/A'}`);
    }
  }
  
  private writeToFile(logEntry: string) {
    try {
      fs.appendFileSync(this.logFile, logEntry);
    } catch (error) {
      originalConsoleError('Failed to write to log file:', error);
    }
  }

  log(message: string) {
    const timestamp = new Date().toISOString();
    const logEntry = `[${timestamp}] ${message}\n`;
    
    // Always log to console using original function
    originalConsoleLog(message);
    
    // Also log to file
    this.writeToFile(logEntry);
  }
  
  error(message: string, error?: any) {
    const errorMsg = error ? `${message}: ${error.message || error}` : message;
    const fullMessage = `‚ùå ERROR: ${errorMsg}`;

    const timestamp = new Date().toISOString();
    const logEntry = `[${timestamp}] ${fullMessage}\n`;
    
    // Log to original console
    originalConsoleError(fullMessage);
    
    // Also log to file
    this.writeToFile(logEntry);

    if (error?.stack) {
      const stackLogEntry = `[${timestamp}] üìç Stack: ${error.stack}\n`;
      originalConsoleError(`üìç Stack: ${error.stack}`);
      this.writeToFile(stackLogEntry);
    }
    
    // For Windows, also try to show a notification
    if (this.debugMode && app.isPackaged) {
      try {
        const { Notification } = require('electron');
        if (Notification.isSupported()) {
          new Notification({
            title: 'MetaKeyAI Error',
            body: errorMsg.substring(0, 100) + (errorMsg.length > 100 ? '...' : ''),
            urgency: 'critical'
          }).show();
        }
      } catch (notifError) {
        // Ignore notification errors
      }
    }
  }
  
  debug(message: string) {
    if (this.debugMode) {
      this.log(`üêõ DEBUG: ${message}`);
    }
  }
  
  getLogPath(): string {
    return this.logFile;
  }
  
  getLogDirectory(): string {
    return path.dirname(this.logFile);
  }
}

const logger = new WindowsLogger();

// Override console methods to use our logger
console.log = (...args) => {
  const message = args.map(arg => {
    if (typeof arg === 'object' && arg !== null) {
      try {
        return JSON.stringify(arg);
      } catch {
        return '[Unstringifiable Object]';
      }
    }
    return String(arg);
  }).join(' ');
  logger.log(message);
};

console.error = (...args) => {
  const errorInstance = args.find(arg => arg instanceof Error);
  const message = args
    .filter(arg => !(arg instanceof Error))
    .map(arg => {
      if (typeof arg === 'object' && arg !== null) {
        try {
          return JSON.stringify(arg);
        } catch {
          return '[Unstringifiable Object]';
        }
      }
      return String(arg);
    }).join(' ');
  
  logger.error(message, errorInstance);
};

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

const handleClipboardNext = () => {
  console.log('‚û°Ô∏è handleClipboardNext triggered!');
  if (!clipboardHistory) return;
  
  const entry = clipboardHistory.cycleNext();
  showPastille(); // Always show pastille to see current state
  if (entry) {
    console.log('üìã Next clipboard entry:', entry.text.substring(0, 50) + '...');
  }
};

const handleClipboardPrevious = () => {
  console.log('‚¨ÖÔ∏è handleClipboardPrevious triggered!');
  if (!clipboardHistory) return;
  
  const entry = clipboardHistory.cyclePrevious();
  showPastille(); // Always show pastille to see current state
  if (entry) {
    console.log('üìã Previous clipboard entry:', entry.text.substring(0, 50) + '...');
  }
};

const handleShowClipboard = () => {
  console.log('üëÅÔ∏è handleShowClipboard triggered!');
  
  // Check if pastille exists and is visible
  if (pastilleWindow && pastilleWindow.isVisible()) {
    // Check if it's actually in front (focused) or behind other windows
    if (pastilleWindow.isFocused() || pastilleWindow.isAlwaysOnTop()) {
      console.log('üëÅÔ∏è Pastille already visible and in front - hiding it');
      pastilleWindow.hide();
    } else {
      console.log('üëÅÔ∏è Pastille visible but behind other windows - bringing to front');
      pastilleWindow.focus();
      pastilleWindow.moveTop();
    }
  } else {
    console.log('üëÅÔ∏è Pastille not visible - showing it');
    showPastille(); // Show current clipboard state
  }
};

const showPastille = () => {
  if (!pastilleWindow || !clipboardHistory) return;
  
  const currentEntry = clipboardHistory.getCurrentEntry();
  const currentIndex = clipboardHistory.getCurrentIndex();
  const totalCount = clipboardHistory.getHistoryLength();
  
  // Get fresh cursor position each time
  const cursorPosition = screen.getCursorScreenPoint();
  const { width: screenWidth, height: screenHeight } = screen.getPrimaryDisplay().workAreaSize;
  
  // Calculate position with bounds checking
  let x = cursorPosition.x + 20;
  let y = cursorPosition.y - 60;
  
  // Keep pastille on screen
  if (x + 520 > screenWidth) {
    x = cursorPosition.x - 540; // Show to the left of cursor
  }
  if (y < 0) {
    y = cursorPosition.y + 20; // Show below cursor
  }
  
  console.log('üñ±Ô∏è Cursor position:', cursorPosition, '-> Pastille position:', { x, y });
  
  pastilleWindow.setPosition(x, y);
  
  pastilleWindow.webContents.send('clipboard-updated', {
    entry: currentEntry,
    currentIndex: currentIndex,
    totalCount: totalCount
  });
  
  pastilleWindow.webContents.send('show-pastille');
  pastilleWindow.show(); // Make sure the window is shown
  console.log('üëÅÔ∏è Pastille window shown at cursor position');
};

const handleQuickEdit = async (): Promise<void> => {
  console.log('üöÄ handleQuickEdit triggered!');
  
  // Check if Python is configured
  const pythonSetup = PythonSetupManager.getInstance();
  const setupStatus = await pythonSetup.checkSetupStatus();
  
  if (!setupStatus.isConfigured) {
    console.log('‚ö†Ô∏è Python not configured for Quick Edit');
    
    pastilleWindow?.webContents.send('show-message', 'Python setup required for Quick Edit. Check Settings ‚Üí Python Setup.');
    pastilleWindow?.show();
    
    // Open settings after a delay to show the message first
    setTimeout(() => {
      openSettingsWindow();
    }, 2000);
    return;
  }
  
  const text = clipboard.readText();
  console.log('üìã Clipboard text:', text ? `"${text}"` : 'EMPTY');
  if (!text) {
    console.log('‚ùå No text in clipboard');
    
    pastilleWindow?.webContents.send('show-message', 'Quick Edit ‚Äì No text in clipboard!');
    pastilleWindow?.show();
    return;
  }

  console.log('‚è≥ Starting Quick Edit processing...');
  
  pastilleWindow?.webContents.send('show-processing', 'Processing');
  pastilleWindow?.show();

  // First try Python daemon quick edit
  let response: string | null = null;
  try {
    response = await callDaemonQuickEdit(text);
    console.log('üêç Daemon quick edit response:', response ? `"${response}"` : 'NULL');
  } catch (err) {
    console.error('üêç Daemon quick edit error:', (err as Error).message);
  }

  console.log('üìù Quick Edit response:', response ? `"${response}"` : 'NULL');

  if (response) {
    clipboard.writeText(response);
    console.log('‚úÖ Text processed and copied to clipboard');
    
    pastilleWindow?.webContents.send('show-message', response);
    pastilleWindow?.show();
  } else {
    console.log('‚ùå Failed to process text');
    
    pastilleWindow?.webContents.send('show-message', 'Quick Edit ‚Äì Failed to process text!');
    pastilleWindow?.show();
  }
};

const processRecording = async (filePath: string) => {
  try {
    console.log(`üîÑ Processing recording from ${filePath}`);
    const transcript = await callWhisperApi(filePath);
    console.log('üìù Whisper transcript:', transcript ? `"${transcript}"` : 'NULL');

    if (transcript) {
      // Save transcript to a file next to the recording
      const transcriptPath = filePath.replace('.wav', '.txt');
      fs.writeFileSync(transcriptPath, transcript);
      
      // Copy to clipboard
      clipboard.writeText(transcript);
      
      console.log(`üíæ Transcript saved to ${transcriptPath} and copied to clipboard`);
      
      pastilleWindow?.webContents.send('show-message', transcript);
      pastilleWindow?.show();
    } else {
      console.log('‚ùå Failed to transcribe audio');
      
      pastilleWindow?.webContents.send('show-message', 'Failed to transcribe audio.');
      pastilleWindow?.show();
    }
  } catch (e) {
    console.error('‚ùå Error processing recording:', e);
    
    pastilleWindow?.webContents.send('show-message', `Error ‚Äì Failed to process recording: ${e.message}`);
    pastilleWindow?.show();
  } finally {
    // Clean up the recording file
    // fs.unlink(filePath, (err) => {
    //   if (err) console.error(`Failed to delete audio file: ${filePath}`, err);
    //   else console.log(`Deleted audio file: ${filePath}`);
    // });
  }
};

const handleVoiceRecord = async () => {
  console.log('üé§ handleVoiceRecord triggered!');
  
  // Use AudioManager for unified recording
  if (!audioManager) {
    console.error('‚ùå AudioManager not available');
    pastilleWindow?.webContents.send('show-message', 'Audio system not available.');
    pastilleWindow?.show();
    return;
  }

  try {
    // Check if there's already an active voice recording session
    const activeSessionIds = audioManager.getActiveSessionIds();
    const voiceRecordSession = activeSessionIds.find(id => id === 'voice-record');
    
    if (voiceRecordSession) {
      console.log('üõë Voice recording already active, stopping it...');
      
      // Stop the existing recording session
      const stopResult = await audioManager.stopRecordingSession('voice-record');
      
      if (stopResult.success) {
        console.log('‚úÖ Existing voice recording stopped');
        pastilleWindow?.webContents.send('show-message', 'Recording stopped.');
        pastilleWindow?.show();
        
        // Process the recording if we got a file
        if (stopResult.filePath) {
          processRecording(stopResult.filePath);
        }
      } else {
        console.error('‚ùå Failed to stop existing recording:', stopResult.error);
        pastilleWindow?.webContents.send('show-message', `Stop Recording Error ‚Äì ${stopResult.error}`);
        pastilleWindow?.show();
      }
      return;
    }
    
    // Start a new recording session using the pastille window
    const session = await audioManager.startRecordingSession({
      sessionId: 'voice-record',
      windowType: 'pastille',
      filePrefix: 'voice_recording',
      eventPrefix: 'pastille'
    });

    if (session.success) {
      console.log('‚úÖ Voice recording started');
      pastilleWindow?.webContents.send('start-recording', 'Recording... Press Ctrl+Alt+W to stop.');
      pastilleWindow?.show();
      
      // Set up a one-time listener for when the recording finishes
      const finishHandler = (filePath: string) => {
        console.log('‚úÖ Voice recording finished, file:', filePath);
        processRecording(filePath);
      };
      
      // Listen for completion (AudioManager will emit via the session)
      // This is handled through the IPC event system in AudioManager
      
    } else {
      console.error('‚ùå Failed to start voice recording:', session.error);
      pastilleWindow?.webContents.send('show-message', `Recording Error ‚Äì ${session.error}`);
      pastilleWindow?.show();
    }
  } catch (error) {
    console.error('‚ùå Voice recording error:', error);
    pastilleWindow?.webContents.send('show-message', `Recording Setup Error ‚Äì ${(error as Error).message}`);
    pastilleWindow?.show();
  }
};

const handleTextToSpeech = async () => {
  console.log('üîä handleTextToSpeech triggered!');
  if (!config.OPENAI_API_KEY) {
    console.log('‚ùå No OpenAI API key found');
    
    pastilleWindow?.webContents.send('show-message', 'Configuration Error: OpenAI API key is not set.');
    pastilleWindow?.show();
    return;
  }

  const text = clipboard.readText();
  console.log('üìã Clipboard text for TTS:', text ? `"${text.substring(0, 100)}..."` : 'EMPTY');
  
  if (!text) {
    console.log('‚ùå No text in clipboard');
    
    pastilleWindow?.webContents.send('show-message', 'Text-to-Speech - No text in clipboard!');
    pastilleWindow?.show();
    return;
  }

  // Stop any currently playing audio
  if (audioPlayer && audioPlayer.playing) {
    console.log('üõë Stopping current audio playback');
    audioPlayer.stop();
    
    pastilleWindow?.webContents.send('show-message', 'Audio playback stopped.');
    pastilleWindow?.show();
    return;
  }

  console.log('‚è≥ Starting TTS processing...');
  
  pastilleWindow?.webContents.send('show-processing', 'Generating speech');
  pastilleWindow?.show();

  try {
    const audioFilePath = await callTextToSpeechApi(text, config.TTS_VOICE);
    console.log('üéµ TTS response:', audioFilePath ? `"${audioFilePath}"` : 'NULL');

    if (audioFilePath) {
      console.log('üîä Starting audio playback...');
      
      pastilleWindow?.webContents.send('show-message', 'üîä Playing audio... (Ctrl+Alt+E to stop)');
      pastilleWindow?.show();

      // Initialize audio player if needed
      if (!audioPlayer) {
        audioPlayer = AudioPlayer.getInstance();
        
        audioPlayer.on('finished', () => {
          console.log('‚úÖ Audio playback finished');
          
          pastilleWindow?.webContents.send('show-message', 'Audio playback completed.');
          pastilleWindow?.show();
          
          // Clean up the temporary file
          setTimeout(() => {
            if (fs.existsSync(audioFilePath)) {
              fs.unlinkSync(audioFilePath);
              console.log('üóëÔ∏è Cleaned up temporary audio file');
            }
          }, 1000);
        });

        audioPlayer.on('error', (error) => {
          console.error('‚ùå Audio playback error:', error);
          
          pastilleWindow?.webContents.send('show-message', `Audio Error ‚Äì ${error.message}`);
          pastilleWindow?.show();
        });

        audioPlayer.on('stopped', () => {
          console.log('üõë Audio playback stopped');
        });
      }

      await audioPlayer.play(audioFilePath);
    } else {
      console.log('‚ùå Failed to generate speech');
      
      pastilleWindow?.webContents.send('show-message', 'Text-to-Speech ‚Äì Failed to generate audio!');
      pastilleWindow?.show();
    }
  } catch (error) {
    console.error('‚ùå TTS error:', error);
    
    pastilleWindow?.webContents.send('show-message', `TTS Error ‚Äì ${error.message}`);
    pastilleWindow?.show();
  }
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', async () => {
  console.log('üöÄ MetaKeyAI starting up...');
  
  // Setup microphone permission handler for Web Audio APIs
  console.log('üé§ Setting up microphone permission handler...');
  session.defaultSession.setPermissionRequestHandler((webContents, permission, callback) => {
    console.log('üîê Permission request:', permission);
    if (permission === 'media') {
      console.log('‚úÖ Granting microphone access for Web Audio APIs');
      callback(true); // Allow microphone access
    } else {
      console.log('‚ùå Denying permission:', permission);
      callback(false);
    }
  });
  
  // Create debug menu for Windows
  createDebugMenu();
  
  // Initialize components
  await initializeApp();
});

const createMainWindow = () => {
  // If main window already exists, focus it
  if (mainWindow) {
    mainWindow.focus();
    return;
  }

  console.log('ü™ü Creating main window...');
  mainWindow = new BrowserWindow({
    width: 800,
    height: 600,
    minWidth: 600,
    minHeight: 500,
    title: 'MetaKeyAI',
    icon: null,
    show: false,
    frame: true,
    titleBarStyle: process.platform === 'darwin' ? 'hiddenInset' : 'default',
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false,
    },
  });

  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  mainWindow.once('ready-to-show', () => {
    mainWindow?.show();
    mainWindow?.focus();
    console.log('‚úÖ Main window ready and shown');
  });

  // For Linux, also ensure the window shows after load
  mainWindow.webContents.once('did-finish-load', () => {
    if (mainWindow && !mainWindow.isVisible()) {
      mainWindow.show();
      mainWindow.focus();
      console.log('üêß Main window forced to show on Linux');
    }
  });

  mainWindow.on('closed', () => {
    mainWindow = null;
    console.log('üö™ Main window closed');
  });

  // Hide to tray instead of closing on Windows
  if (process.platform === 'win32') {
    mainWindow.on('close', (event) => {
      if (mainWindow && !(app as any).isQuitting) {
        event.preventDefault();
        mainWindow.hide();
        showPillNotification('MetaKeyAI is still running in the background');
      }
    });
  }
};

const openSettingsWindow = () => {
  // If settings window already exists, focus it
  if (settingsWindow) {
    settingsWindow.focus();
    return;
  }

  console.log('ü™ü Creating settings window...');
  settingsWindow = new BrowserWindow({
    width: 700,
    height: 900,
    minWidth: 600,
    minHeight: 700,
    title: 'MetaKeyAI Settings',
    icon: null, // You can add an icon here
    show: false,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false,
    },
  });

  settingsWindow.loadURL(SETTINGS_WINDOW_WEBPACK_ENTRY);

  settingsWindow.once('ready-to-show', () => {
    settingsWindow?.show();
    console.log('‚úÖ Settings window ready and shown');
  });

  settingsWindow.on('closed', () => {
    settingsWindow = null;
    console.log('üö™ Settings window closed');
  });
};

const openSpellBookWindow = () => {
  // If spell book window already exists, focus it
  if (spellBookWindow) {
    spellBookWindow.focus();
    return;
  }

  console.log('ü™ü Creating spell book window...');
  spellBookWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    minWidth: 800,
    minHeight: 600,
    title: 'Python Spell Book - MetaKeyAI',
    icon: null,
    show: false,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false,
    },
  });

  // Load the spell book HTML file
  spellBookWindow.loadURL(SPELL_BOOK_WINDOW_WEBPACK_ENTRY);

  spellBookWindow.once('ready-to-show', () => {
    spellBookWindow?.show();
    console.log('‚úÖ Spell book window ready and shown');
  });

  spellBookWindow.on('closed', () => {
    spellBookWindow = null;
    console.log('üö™ Spell book window closed');
  });
};

// Since there are no windows, we don't need to handle 'window-all-closed'
// The app will continue running in the background.

// Centralized cleanup function
async function cleanupApplication(): Promise<void> {
  console.log('üßπ Starting application cleanup...');
  
  try {
    // Cleanup Python daemon FIRST (most important)
    console.log('üêç Stopping Python daemon...');
    const daemon = await PythonDaemon.getInstance().catch((): null => null);
    if (daemon) {
      await daemon.stop();
      console.log('‚úÖ Python daemon stopped');
    }
  } catch (error) {
    console.error('‚ùå Error stopping Python daemon:', error);
  }
  
  try {
    // Cleanup shortcuts manager
    if (shortcutsManager) {
      shortcutsManager.cleanup();
      shortcutsManager = null;
      console.log('‚úÖ Shortcuts manager cleaned up');
    }
  } catch (error) {
    console.error('‚ùå Error cleaning up shortcuts manager:', error);
  }
  
  try {
    // Cleanup clipboard history
    if (clipboardHistory) {
      clipboardHistory.destroy();
      clipboardHistory = null;
      console.log('‚úÖ Clipboard history cleaned up');
    }
  } catch (error) {
    console.error('‚ùå Error cleaning up clipboard history:', error);
  }
  
  try {
    // Cleanup audio manager (handles all audio operations)
    if (audioManager) {
      audioManager.cleanup();
      audioManager = null;
      console.log('‚úÖ Audio manager cleaned up');
    }
    
    // Legacy audio component cleanup
    if (audioPlayer) {
      audioPlayer.stop();
      audioPlayer = null;
      console.log('‚úÖ Audio player cleaned up');
    }
    
    if (audioManager) {
      // Stop any ongoing recording and cleanup
      audioManager.cleanup();
      console.log('‚úÖ Audio manager cleaned up');
    }
  } catch (error) {
    console.error('‚ùå Error cleaning up audio components:', error);
  }
  
  try {
    // Cleanup Python Spell Caster
    if (spellCaster) {
      spellCaster.cleanup();
      spellCaster = null;
      console.log('‚úÖ Python spell caster cleaned up');
    }
  } catch (error) {
    console.error('‚ùå Error cleaning up spell caster:', error);
  }

  try {
    // Cleanup first run manager
    if (firstRunManager) {
      firstRunManager.destroy();
      firstRunManager = null;
      console.log('‚úÖ First run manager cleaned up');
    }
  } catch (error) {
    console.error('‚ùå Error cleaning up first run manager:', error);
  }
  
  try {
    // Unregister all global shortcuts
    globalShortcut.unregisterAll();
    console.log('‚úÖ Global shortcuts unregistered');
  } catch (error) {
    console.error('‚ùå Error unregistering shortcuts:', error);
  }
  
  console.log('üßπ Application cleanup completed');
}

// Handle app shutdown events
app.on('will-quit', async (event) => {
  // Prevent immediate quit to allow cleanup
  event.preventDefault();
  (app as any).isQuitting = true;
  console.log('üõë App will quit - starting cleanup...');
  
  try {
    await cleanupApplication();
  } catch (error) {
    console.error('‚ùå Error during cleanup:', error);
  } finally {
    // Force quit after cleanup
    app.exit(0);
  }
});

// Handle Windows-specific shutdown events
app.on('before-quit', async (event) => {
  console.log('üõë Before quit event triggered');
  // The cleanup will be handled in will-quit
});

// Handle session end (Windows logout, restart, etc.)
process.on('SIGTERM', async () => {
  console.log('üõë SIGTERM received - shutting down gracefully...');
  await cleanupApplication();
  process.exit(0);
});

process.on('SIGINT', async () => {
  console.log('üõë SIGINT received - shutting down gracefully...');
  await cleanupApplication();
  process.exit(0);
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

/**
 * Shows a pill-style notification instead of the system notification.
 * Positions it near the bottom-right of the primary display.
 */
const showPillNotification = (message: string) => {
  if (!pastilleWindow) {
    console.warn('Pastille window not ready, cannot show pill notification');
    return;
  }

  const { width: screenWidth, height: screenHeight } = screen.getPrimaryDisplay().workAreaSize;

  const x = screenWidth - 500; // leave some margin
  const y = screenHeight - 100;

  pastilleWindow.setPosition(x, y);
  pastilleWindow.webContents.send('show-message', message);
  pastilleWindow.show();
};

// Spell feedback system
const showSpellLaunchFeedback = (spellName: string) => {
  console.log('‚ú® Launching spell:', spellName);
  
  if (!pastilleWindow) return;
  
  // Position near cursor for immediate feedback
  
  
  // Show magical launching message
  pastilleWindow.webContents.send('show-spell-launch', `‚ú® Casting ${spellName}...`);
  pastilleWindow.show();
};

const showSpellCompletionFeedback = (result: any) => {
  const output = result?.output || result;
  console.log('üéØ ‚ú® Spell completed! Result length:', output.length);
  
  if (!pastilleWindow) return;
  
  // Position near cursor and show magical result
  
  pastilleWindow.webContents.send('show-spell-result', output);
  pastilleWindow.show();
  
  // Wait a moment for the clipboard to be updated, then navigate to the newest entry (index 0)
  setTimeout(() => {
    if (clipboardHistory) {
      // Force navigate to the newest entry (the spell result)
      const newestEntry = clipboardHistory.getHistory()[0];
      if (newestEntry) {
        console.log('üéØ üìã Auto-navigating to spell result:', newestEntry.text.substring(0, 50) + '...');
        // Set current index to 0 to show the newest entry
        (clipboardHistory as any).currentIndex = 0;
        // Update system clipboard to match
        clipboard.writeText(newestEntry.text);
        (clipboardHistory as any).lastClipboardText = newestEntry.text;
        (clipboardHistory as any).isInternalChange = true;
        
        // Emit the change event to update UI
        clipboardHistory.emit('current-changed', newestEntry);
      }
    }
    
    // Show the pastille with the result
    showPastille();
  }, 200);
};

// Add debug menu for Windows
function createDebugMenu(): void {
  if (process.platform === 'win32') {
    const { Menu } = require('electron');
    
    const debugMenu = Menu.buildFromTemplate([
      {
        label: 'Debug',
        submenu: [
          {
            label: 'Open Log File',
            click: () => {
              shell.openPath(logger.getLogPath());
            }
          },
          {
            label: 'Open Log Directory',
            click: () => {
              shell.showItemInFolder(logger.getLogPath());
            }
          },
          {
            label: 'Show Debug Info',
            click: () => {
              const info = {
                platform: process.platform,
                arch: process.arch,
                version: app.getVersion(),
                packaged: app.isPackaged,
                logFile: logger.getLogPath(),
                appData: app.getPath('appData'),
                userData: app.getPath('userData'),
                resourcesPath: process.resourcesPath || 'N/A'
              };
              
              dialog.showMessageBox({
                type: 'info',
                title: 'Debug Information',
                message: 'MetaKeyAI Debug Info',
                detail: JSON.stringify(info, null, 2),
                buttons: ['Copy to Clipboard', 'OK']
              }).then((result) => {
                if (result.response === 0) {
                  clipboard.writeText(JSON.stringify(info, null, 2));
                }
              });
            }
          },
          {
            label: 'Test Audio Recording',
            click: async () => {
              try {
                logger.log('üé§ Testing audio recording via AudioManager...');
                if (audioManager) {
                  const result = await audioManager.testMicrophoneDevice('auto');
                  logger.log(`‚úÖ Audio test completed: ${result.success ? 'SUCCESS' : 'FAILED'}`);
                  dialog.showMessageBox({
                    type: result.success ? 'info' : 'error',
                    title: 'Audio Test',
                    message: result.success ? 
                      `Audio recording test completed successfully! File size: ${result.deviceInfo?.fileSize || 'unknown'} bytes` :
                      `Audio test failed: ${result.error}`,
                    buttons: ['OK']
                  });
                } else {
                  throw new Error('AudioManager not available');
                }
              } catch (error) {
                logger.error('Audio test failed', error);
                dialog.showErrorBox('Audio Test Failed', error.message);
              }
            }
          },
          {
            label: 'Generate Debug Report',
            click: async () => {
              try {
                const report = await generateDebugReport();
                const reportPath = path.join(logger.getLogDirectory(), `debug-report-${Date.now()}.json`);
                fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
                
                dialog.showMessageBox({
                  type: 'info',
                  title: 'Debug Report Generated',
                  message: `Debug report saved to:\n${reportPath}`,
                  buttons: ['Open Report', 'Open Folder', 'OK']
                }).then((result) => {
                  if (result.response === 0) {
                    shell.openPath(reportPath);
                  } else if (result.response === 1) {
                    shell.showItemInFolder(reportPath);
                  }
                });
              } catch (error) {
                logger.error('Failed to generate debug report', error);
                dialog.showErrorBox('Debug Report Failed', error.message);
              }
            }
          }
        ]
      }
    ]);
    
    Menu.setApplicationMenu(debugMenu);
  }
}


async function generateDebugReport() {
  const report: any = {
    timestamp: new Date().toISOString(),
    system: {
      platform: process.platform,
      arch: process.arch,
      nodeVersion: process.version,
      electronVersion: process.versions.electron,
      appVersion: app.getVersion(),
      isPackaged: app.isPackaged,
      appPath: app.getAppPath(),
      userData: app.getPath('userData'),
      resourcesPath: process.resourcesPath || 'N/A'
    },
    environment: {
      NODE_ENV: process.env.NODE_ENV,
      PATH: process.env.PATH,
      APPDATA: process.env.APPDATA,
      LOCALAPPDATA: process.env.LOCALAPPDATA,
      PROGRAMFILES: process.env.PROGRAMFILES,
      'PROGRAMFILES(X86)': process.env['PROGRAMFILES(X86)']
    },
    files: {
      logFile: logger.getLogPath(),
      logDirectory: logger.getLogDirectory(),
      configExists: userDataManager ? fs.existsSync(userDataManager.getModelConfigPath()) : false,
      configPath: userDataManager ? userDataManager.getModelConfigPath() : 'N/A',
      legacyConfigExists: fs.existsSync(LEGACY_ENV_CONFIG_PATH),
      legacyConfigPath: LEGACY_ENV_CONFIG_PATH
    },
    components: {
      audioManager: !!audioManager,
      audioPlayer: !!audioPlayer,
      clipboardHistory: !!clipboardHistory,
      shortcutsManager: !!shortcutsManager,
      tray: !!tray
    }
  };

  // Add recent log entries
  try {
    const logContent = fs.readFileSync(logger.getLogPath(), 'utf-8');
    const logLines = logContent.split('\n').slice(-50); // Last 50 lines
    report.recentLogs = logLines.filter(line => line.trim());
  } catch (error: any) {
    report.recentLogs = [`Failed to read log file: ${error.message}`];
  }

  return report;
}

async function initializeApp() {
  // Initialize user data manager first
  console.log('üìÅ Initializing user data manager...');
  userDataManager = UserDataManager.getInstance();
  console.log('‚úÖ User data manager initialized');
  console.log('üìÅ User data paths:', {
    root: userDataManager.getUserDataRoot(),
    spells: userDataManager.getCustomSpellsDir(),
    python: userDataManager.getPythonEnvDir(),
    settings: userDataManager.getSettingsPath(),
    cache: userDataManager.getCacheDir(),
    database: userDataManager.getDatabaseDir()
  });

  // Initialize audio manager early (sets up IPC handlers needed by first-run setup)
  console.log('üé§ Initializing audio manager...');
  audioManager = AudioManager.getInstance();
  console.log('‚úÖ Audio manager initialized with global IPC handlers');

  // Setup essential IPC handlers early (needed by first-run setup)
  console.log('üîß Setting up essential IPC handlers...');
  setupEssentialIpcHandlers();
  console.log('‚úÖ Essential IPC handlers set up');

  // Initialize first run manager
  console.log('üé¨ Initializing first run manager...');
  firstRunManager = new FirstRunManager(userDataManager, async () => {
    // Initialize normal app after first-run setup is complete
    console.log('üéâ First-run complete, initializing normal app...');
    await initializeNormalApp(true);
  });
  console.log('‚úÖ First run manager initialized');
  
  // Migrate model configuration if needed
  try {
    if (fs.existsSync(LEGACY_ENV_CONFIG_PATH)) {
      const migrated = userDataManager.migrateOldModelConfig(LEGACY_ENV_CONFIG_PATH);
      if (migrated) {
        console.log('üîÑ Model configuration migrated to new location');
      }
    }
  } catch (error) {
    console.warn('‚ö†Ô∏è Model configuration migration failed:', error);
  }
  
  // Load and apply model configuration to environment
  try {
    console.log('ü§ñ Loading model configuration...');
    const modelConfig = readEnvConfig();
    
    if (modelConfig) {
      // Apply environment variables to current process
      Object.entries(modelConfig.env || {}).forEach(([key, value]) => {
        process.env[key] = value;
        // Don't log sensitive values like API keys
        const isSensitive = key.toLowerCase().includes('key') || key.toLowerCase().includes('token') || key.toLowerCase().includes('secret');
        const displayValue = isSensitive ? '***' : (value || 'undefined');
        console.log(`üîß Set env var: ${key} = ${displayValue}`);
      });
      
      // Apply LLM configuration
      if (modelConfig.llm) {
        process.env['METAKEYAI_LLM'] = modelConfig.llm;
        console.log(`ü§ñ Set METAKEYAI_LLM: ${modelConfig.llm}`);
      }
      
      // Update config object for runtime
      (config as any).ENV_VARS = modelConfig.env || {};
      (config as any).DEFAULT_LLM = modelConfig.llm || '';
      (config as any).LLM_LIST = modelConfig.llms || [];
      
      console.log('‚úÖ Model configuration loaded and applied');
    } else {
      console.log('‚ÑπÔ∏è No model configuration found - using defaults');
    }
  } catch (error) {
    console.error('‚ùå Failed to load model configuration:', error);
  }
  
  console.log('üìã Initializing clipboard history...');
  clipboardHistory = new ClipboardHistory(50);
  
  clipboardHistory.on('history-updated', (entry) => {
    console.log('üìã Clipboard history updated:', entry?.text?.substring(0, 50) + '...');
  });
  
  clipboardHistory.on('current-changed', (entry) => {
    console.log('üìã Current clipboard entry changed:', entry?.text?.substring(0, 50) + '...');
  });
  
  console.log('‚úÖ Clipboard history initialized');
  
  // Initialize Python Spell Caster with setup check
  console.log('üßô‚Äç‚ôÇÔ∏è Checking Python setup configuration...');
  try {
    const pythonSetup = PythonSetupManager.getInstance();
    
    // Check if we have a saved Python configuration without triggering initialization
    const hasConfiguration = pythonSetup.getSetupStatus().isConfigured || 
                             pythonSetup.getSetupStatus().setupMethod !== 'none';
    
    if (!hasConfiguration) {
      console.log('‚ö†Ô∏è No Python configuration found - spell caster will initialize on demand');
      
      // Create spell caster but don't initialize it yet
      spellCaster = pythonSpellCaster;
      console.log('‚úÖ Spell Caster ready for on-demand initialization');
    } else {
      console.log('‚úÖ Python configuration found - initializing spell caster...');
      
      // Check detailed setup status and initialize
      const setupStatus = await pythonSetup.checkSetupStatus();
      
      if (!setupStatus.isConfigured) {
        console.log('‚ö†Ô∏è Python configuration exists but not properly configured');
        spellCaster = pythonSpellCaster;
        await spellCaster.initializeFallback();
        console.log('‚ö†Ô∏è Spell Caster initialized with limited functionality');
      } else {
        console.log('‚úÖ Python environment verified - initializing full functionality');
        spellCaster = pythonSpellCaster;
        await spellCaster.initialize();
        console.log('‚úÖ Python Spell Caster initialized');
      }
    }
  } catch (error) {
    console.error('‚ùå Error during Python setup check:', error);
    // Create spell caster for on-demand initialization
    spellCaster = pythonSpellCaster;
    console.log('‚ö†Ô∏è Spell Caster ready for on-demand initialization (after error)');
  }
  
  // Create the pastille window
  console.log('ü™ü Creating pastille window...');
  pastilleWindow = new BrowserWindow({
    width: 500,
    height: 70,
    frame: false,
    transparent: true,
    alwaysOnTop: false,
    show: false,
    resizable: true,
    skipTaskbar: true,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false,
    },
  });

  pastilleWindow.loadURL(PASTILLE_WINDOW_WEBPACK_ENTRY);
  (global as any).pastilleWindow = pastilleWindow; // Make window accessible to other modules
  (global as any).firstRunManager = firstRunManager; // Make first-run manager accessible to AudioManager
  (global as any).audioManager = audioManager; // Make audio manager accessible globally
  pastilleWindow.setIgnoreMouseEvents(false);
  
  // Initialize pastille with current clipboard content once it's ready
  pastilleWindow.webContents.once('did-finish-load', () => {
    console.log('üéØ Pastille window loaded, initializing with current clipboard');
    setTimeout(() => {
      const currentEntry = clipboardHistory?.getCurrentEntry();
      const currentIndex = clipboardHistory?.getCurrentIndex() ?? -1;
      const totalCount = clipboardHistory?.getHistoryLength() ?? 0;
      
      pastilleWindow?.webContents.send('clipboard-updated', {
        entry: currentEntry,
        currentIndex: currentIndex,
        totalCount: totalCount
      });
    }, 100);
  });
  
  console.log('‚úÖ Pastille window created');

  // Create tray icon
  console.log('üñºÔ∏è Creating tray icon...');
  const image = nativeImage.createFromDataURL(
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAEklEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='
  );
  tray = new Tray(image);
  
  const contextMenu = Menu.buildFromTemplate([
    { label: 'Show MetaKeyAI', type: 'normal', click: createMainWindow },
    { type: 'separator' },
    { label: 'Settings', type: 'normal', click: openSettingsWindow },
    { label: 'Spell Book', type: 'normal', click: openSpellBookWindow },
    { type: 'separator' },
    { label: 'Hide All Windows', type: 'normal', click: () => {
        if (pastilleWindow?.isVisible()) pastilleWindow.hide();
        if (settingsWindow?.isVisible()) settingsWindow.hide();
        if (spellBookWindow?.isVisible()) spellBookWindow.hide();
        console.log('üëÅÔ∏è All windows hidden');
      }
    },
    { type: 'separator' },
    { label: 'Quit MetaKeyAI', type: 'normal', accelerator: 'CommandOrControl+Alt+Shift+Q', click: async () => {
        console.log('üõë Quit requested from tray menu');
        app.quit();
      }
    },
  ]);

  tray.setToolTip('MetaKeyAI');
  tray.setContextMenu(contextMenu);
  
  // Double-click tray to show main window
  tray.on('double-click', () => {
    createMainWindow();
  });
  
  console.log('‚úÖ Tray created');
  
  // Handle first-run setup
  if (firstRunManager) {
    console.log('üé¨ Checking if first-run setup should be shown...');
    const wasFirstRun = await firstRunManager.isFirstRun();
    console.log('üîç Was first run?', wasFirstRun);
    
    if (wasFirstRun) {
      console.log('üëã First run detected, delaying normal app initialization...');
      console.log('üé¨ First-run setup will initialize features as needed');
      await firstRunManager.handleAppReady();
      // Normal app initialization will be called from onSetupComplete callback
    } else {
      console.log('‚úÖ Not first run, starting normal initialization...');
      await initializeNormalApp();
    }
  } else {
    // No first run manager, start normal initialization
    console.log('‚ö†Ô∏è No first run manager, starting normal initialization...');
    await initializeNormalApp();
  }
}

async function initializeNormalApp(isFirstRunComplete = false): Promise<void> {
  console.log('üöÄ Starting normal app initialization...');
  
  // Create main window
  createMainWindow();
  
  // Initialize shortcuts
  await initializeShortcuts();
  
  // Setup IPC listeners
  setupIpcListeners();
  
  // Check API key and show notifications
  if (!config.OPENAI_API_KEY) {
    console.log('‚ö†Ô∏è No OpenAI API key found in config');
    showPillNotification('Configuration Warning ‚Äì OpenAI API key not set. Voice and edit features will not work.');
  } else {
    console.log('‚úÖ OpenAI API key found in config');
  }

  // Show welcome notification (different message for first-run completion)
  if (isFirstRunComplete) {
    showPillNotification('Welcome to MetaKeyAI! üéâ\nSetup complete - you\'re ready to go!\nCtrl+Alt+Q: Quick edit\nCtrl+Alt+W: Voice record\nCtrl+Alt+E: Text-to-speech\nCtrl+Alt+C: Show/hide clipboard\nCtrl+Alt+‚Üê/‚Üí: Navigate clipboard\nCtrl+Alt+Shift+Q: Quit app\nCustomize shortcuts in Settings!');
  } else {
    showPillNotification('MetaKeyAI running in background\nCtrl+Alt+Q: Quick edit\nCtrl+Alt+W: Voice record\nCtrl+Alt+E: Text-to-speech\nCtrl+Alt+C: Show/hide clipboard\nCtrl+Alt+‚Üê/‚Üí: Navigate clipboard\nCtrl+Alt+Shift+Q: Quit app\nCustomize shortcuts in Settings!');
  }
  
  console.log('‚úÖ Normal app initialization complete');
}

async function initializeShortcuts() {
  console.log('‚å®Ô∏è Initializing shortcuts manager...');
  
  // Initialize shortcuts manager
  shortcutsManager = ShortcutsManager.getInstance();
  
  // Define all shortcut handlers
  const shortcutHandlers = {
    'quick-edit': handleQuickEdit,
    'voice-record': handleVoiceRecord,
    'text-to-speech': handleTextToSpeech,
    'clipboard-show': handleShowClipboard,
    'clipboard-next': handleClipboardNext,
    'clipboard-previous': handleClipboardPrevious,
    'clipboard-next-alt1': handleClipboardNext,
    'clipboard-previous-alt1': handleClipboardPrevious,
    'clipboard-next-alt2': handleClipboardNext,
    'clipboard-previous-alt2': handleClipboardPrevious,
    'spells-analysis': async () => {
      const clipboardContent = clipboard.readText();
      const spells = spellCaster?.getSpellBook().filter((s: any) => s.category === 'analysis') || [];
      if (spells.length > 0) {
        const spell = spells[0];
        showSpellLaunchFeedback(spell.name || 'Analysis Spell');
        try {
          const result = await spellCaster?.castSpell(spell.id, clipboardContent);
          if (result) {
            showSpellCompletionFeedback(result);
          }
        } catch (error) {
          showPillNotification(`Spell failed: ${(error as Error).message}`);
        }
      }
    },
    'spells-data': async () => {
      const clipboardContent = clipboard.readText();
      const spells = spellCaster?.getSpellBook().filter((s: any) => s.category === 'data') || [];
      if (spells.length > 0) {
        const spell = spells[0];
        showSpellLaunchFeedback(spell.name || 'Data Spell');
        try {
          const result = await spellCaster?.castSpell(spell.id, clipboardContent);
          if (result) {
            showSpellCompletionFeedback(result);
          }
        } catch (error) {
          showPillNotification(`Spell failed: ${(error as Error).message}`);
        }
      }
    },
    'spells-text': async () => {
      const clipboardContent = clipboard.readText();
      const spells = spellCaster?.getSpellBook().filter((s: any) => s.category === 'text') || [];
      if (spells.length > 0) {
        const spell = spells[0];
        showSpellLaunchFeedback(spell.name || 'Text Spell');
        try {
          const result = await spellCaster?.castSpell(spell.id, clipboardContent);
          if (result) {
            showSpellCompletionFeedback(result);
          }
        } catch (error) {
          showPillNotification(`Spell failed: ${(error as Error).message}`);
        }
      }
    },
    // Quick spell slots
    'spell-slot-1': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        const spell = spellCaster?.getQuickSlots()[0];
        if (spell) {
          showSpellLaunchFeedback(spell.name || 'Quick Spell 1');
          const result = await spellCaster?.castQuickSpell(1, clipboardContent);
          if (result) {
            showSpellCompletionFeedback(result);
          }
        } else {
          showPillNotification('No spell assigned to slot 1');
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Quick spell slot 1:', (error as Error).message);
        showPillNotification('No spell assigned to slot 1');
      }
    },
    'spell-slot-2': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        const spell = spellCaster?.getQuickSlots()[1];
        if (spell) {
          showSpellLaunchFeedback(spell.name || 'Quick Spell 2');
          const result = await spellCaster?.castQuickSpell(2, clipboardContent);
          if (result) {
            showSpellCompletionFeedback(result);
          }
        } else {
          showPillNotification('No spell assigned to slot 2');
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Quick spell slot 2:', (error as Error).message);
        showPillNotification('No spell assigned to slot 2');
      }
    },
    'spell-slot-3': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        const spell = spellCaster?.getQuickSlots()[2];
        if (spell) {
          showSpellLaunchFeedback(spell.name || 'Quick Spell 3');
          const result = await spellCaster?.castQuickSpell(3, clipboardContent);
          if (result) {
            showSpellCompletionFeedback(result);
          }
        } else {
          showPillNotification('No spell assigned to slot 3');
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Quick spell slot 3:', (error as Error).message);
        showPillNotification('No spell assigned to slot 3');
      }
    },
    'spell-slot-4': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        const spell = spellCaster?.getQuickSlots()[3];
        if (spell) {
          showSpellLaunchFeedback(spell.name || 'Quick Spell 4');
          const result = await spellCaster?.castQuickSpell(4, clipboardContent);
          if (result) {
            showSpellCompletionFeedback(result);
          }
        } else {
          showPillNotification('No spell assigned to slot 4');
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Quick spell slot 4:', (error as Error).message);
        showPillNotification('No spell assigned to slot 4');
      }
    },
    'spell-slot-5': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        const spell = spellCaster?.getQuickSlots()[4];
        if (spell) {
          showSpellLaunchFeedback(spell.name || 'Quick Spell 5');
          const result = await spellCaster?.castQuickSpell(5, clipboardContent);
          if (result) {
            showSpellCompletionFeedback(result);
          }
        } else {
          showPillNotification('No spell assigned to slot 5');
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Quick spell slot 5:', (error as Error).message);
        showPillNotification('No spell assigned to slot 5');
      }
    },
    'spell-slot-6': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        const spell = spellCaster?.getQuickSlots()[5];
        if (spell) {
          showSpellLaunchFeedback(spell.name || 'Quick Spell 6');
          const result = await spellCaster?.castQuickSpell(6, clipboardContent);
          if (result) {
            showSpellCompletionFeedback(result);
          }
        } else {
          showPillNotification('No spell assigned to slot 6');
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Quick spell slot 6:', (error as Error).message);
        showPillNotification('No spell assigned to slot 6');
      }
    },
    'spell-slot-7': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        const spell = spellCaster?.getQuickSlots()[6];
        if (spell) {
          showSpellLaunchFeedback(spell.name || 'Quick Spell 7');
          const result = await spellCaster?.castQuickSpell(7, clipboardContent);
          if (result) {
            showSpellCompletionFeedback(result);
          }
        } else {
          showPillNotification('No spell assigned to slot 7');
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Quick spell slot 7:', (error as Error).message);
        showPillNotification('No spell assigned to slot 7');
      }
    },
    'spell-slot-8': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        const spell = spellCaster?.getQuickSlots()[7];
        if (spell) {
          showSpellLaunchFeedback(spell.name || 'Quick Spell 8');
          const result = await spellCaster?.castQuickSpell(8, clipboardContent);
          if (result) {
            showSpellCompletionFeedback(result);
          }
        } else {
          showPillNotification('No spell assigned to slot 8');
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Quick spell slot 8:', (error as Error).message);
        showPillNotification('No spell assigned to slot 8');
      }
    },
    'spell-slot-9': async () => { 
      try {
        const clipboardContent = clipboard.readText();
        const spell = spellCaster?.getQuickSlots()[8];
        if (spell) {
          showSpellLaunchFeedback(spell.name || 'Quick Spell 9');
          const result = await spellCaster?.castQuickSpell(9, clipboardContent);
          if (result) {
            showSpellCompletionFeedback(result);
          }
        } else {
          showPillNotification('No spell assigned to slot 9');
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Quick spell slot 9:', (error as Error).message);
        showPillNotification('No spell assigned to slot 9');
      }
    },
    // Application control
    'app-quit': async () => {
      console.log('üõë App quit shortcut triggered');
      showPillNotification('MetaKeyAI shutting down...');
      // Give user a moment to see the message
      setTimeout(() => {
        app.quit();
      }, 1000);
    },
  };
  
  // Set handlers and initialize
  shortcutsManager.setHandlers(shortcutHandlers);
  await shortcutsManager.initialize();
  
  console.log('‚úÖ Shortcuts initialized');
}

// Global variables to track edit session
let editSessionData: {
  originalIndex: number;
  originalText: string;
  isActive: boolean;
} | null = null;

function setupEssentialIpcHandlers(): void {
  // Essential IPC handlers needed by first-run setup and other early components
  
  try {
    // Environment configuration handlers
    ipcMain.handle('load-env', () => {
      console.log('üîß IPC: load-env called');
      return readEnvConfig();
    });

    ipcMain.handle('save-env', async (event, { env, llm, llms }) => {
      console.log('üîß IPC: save-env called');
      try {
        // Persist to disk (includes llms list)
        writeEnvConfig({ env, llm, llms });

        // Apply to current process env and config
        Object.entries(env).forEach(([k,v]) => process.env[k]=v as string);
        if (llm) process.env['METAKEYAI_LLM'] = llm;

        (config as any).ENV_VARS = env;
        (config as any).DEFAULT_LLM = llm;
        (config as any).LLM_LIST = llms;

        // Notify daemon if available
        try {
          const daemon = await PythonDaemon.getInstance();
          const res = await daemon.updateEnv({ ...env, METAKEYAI_LLM: llm });
          return { ok: res?.ok !== false, msg: res?.msg || '' };
        } catch (error) {
          console.warn('‚ö†Ô∏è Could not notify daemon of env changes:', (error as Error).message);
          return { ok: true, msg: 'Saved (daemon not available)' };
        }
      } catch (err) {
        console.error('‚ùå Failed to save env config:', err);
        return { ok: false, msg: (err as Error).message };
      }
    });

    // Voice testing (needed by first-run setup)
    ipcMain.on('test-voice', async (event, { voice, text }) => {
      console.log('üîä Testing voice from setup/settings:', voice);
      try {
        const audioFilePath = await callTextToSpeechApi(text, voice);
        if (audioFilePath && audioManager) {
          await audioManager.playAudioFile(audioFilePath);
        }
      } catch (error) {
        console.error('‚ùå Voice test error:', error);
      }
    });

    // UserDataManager access handlers
    ipcMain.handle('get-user-settings', () => {
      console.log('üîß IPC: get-user-settings called');
      return userDataManager?.getSettings() || {};
    });

    ipcMain.handle('save-user-settings', (event, settings) => {
      console.log('üîß IPC: save-user-settings called');
      userDataManager?.saveSettings(settings);
      return { success: true };
    });

    ipcMain.handle('update-user-settings', (event, partialSettings) => {
      console.log('üîß IPC: update-user-settings called');
      userDataManager?.updateSettings(partialSettings);
      return { success: true };
    });

    ipcMain.handle('load-audio-settings', () => {
      console.log('üîß IPC: load-audio-settings called');
      return userDataManager?.loadAudioSettings();
    });

    ipcMain.handle('save-audio-settings', (event, settings) => {
      console.log('üîß IPC: save-audio-settings called');
      userDataManager?.saveAudioSettings(settings);
      return { success: true };
    });

    // Settings access (needed by first-run setup for device selection)
    ipcMain.handle('get-settings', () => {
      console.log('üîß IPC: get-settings called');
      return {
        OPENAI_API_KEY: config.OPENAI_API_KEY || '',
        WHISPER_MODEL: config.WHISPER_MODEL,
        TTS_VOICE: config.TTS_VOICE,
        MICROPHONE_DEVICE: audioManager?.getMicrophoneDevice() || 'auto'
      };
    });

    // Python setup status (needed by first-run setup)
    ipcMain.handle('check-python-setup', async () => {
      console.log('üîß IPC: check-python-setup called');
      try {
        const setupManager = PythonSetupManager.getInstance();
        const status = await setupManager.checkSetupStatus();
        return status;
      } catch (error) {
        console.error('Failed to check Python setup:', error);
        return {
          isConfigured: false,
          uvAvailable: false,
          uvPath: null,
          pythonPath: null,
          projectPath: null,
          customPythonPath: null,
          setupMethod: 'none',
          dependencies: { fastapi: false, uvicorn: false, dspy: false },
          errors: [(error as Error).message]
        };
      }
    });

    console.log('‚úÖ Essential IPC handlers registered');
  } catch (error) {
    console.error('‚ùå Failed to setup essential IPC handlers:', error);
    throw error;
  }
}

function setupIpcListeners(): void {
  // Add IPC listener for edit-mode-start
  ipcMain.on('edit-mode-start', (event, { entryIndex, entryText }) => {
    console.log('üìù üöÄ EDIT MODE STARTED for entry:', entryIndex, 'Text preview:', entryText.substring(0, 50) + '...');
    editSessionData = {
      originalIndex: entryIndex,
      originalText: entryText,
      isActive: true
    };
    if (clipboardHistory) {
      clipboardHistory.setEditModeActive(true);
      console.log('üìù ‚úÖ Edit mode activated in clipboard history');
    } else {
      console.error('üìù ‚ùå No clipboard history instance available!');
    }
  });

  // Add IPC listener for update-clipboard (final save)
  ipcMain.on('update-clipboard', (event, text, mode) => {
    console.log('üìã Received update-clipboard event - mode:', mode || 'save');
    
    if (!editSessionData || !editSessionData.isActive) {
      console.warn('üìù No active edit session, treating as regular clipboard update');
      clipboard.writeText(text);
      if (clipboardHistory) {
        clipboardHistory.addEntryWithReplacement(text, undefined);
      }
      showPastille();
      return;
    }
    
    const editMode = mode || 'save'; // default to save
    if (clipboardHistory) {
      clipboardHistory.handleEditComplete(text, editMode, editSessionData.originalIndex);
    }
    
    // Clear edit session
    editSessionData = null;
    
    console.log('üìã Edit session completed with mode:', editMode);
    showPastille();
  });
  
  // Add IPC listener for update-clipboard-draft (auto-save - just updates system clipboard)
  ipcMain.on('update-clipboard-draft', (event, text) => {
    console.log('üìù Draft update received - should NOT trigger history. Edit mode active?', editSessionData?.isActive);
    // Only update system clipboard silently, no history updates
    clipboard.writeText(text);
    // Update last known text to prevent monitoring pickup
    if (clipboardHistory) {
      (clipboardHistory as any).lastClipboardText = text;
    }
  });

  // Add IPC listener for expand-pastille
  ipcMain.on('expand-pastille', () => {
    if (pastilleWindow) {
      const { width: screenWidth, height: screenHeight } = screen.getPrimaryDisplay().workAreaSize;
      const targetWidth = Math.round(screenWidth * 0.7);
      const targetHeight = Math.round(screenHeight * 0.6);
      pastilleWindow.setAlwaysOnTop(true);
      pastilleWindow.setSize(targetWidth, targetHeight, true);
      pastilleWindow.center();
    }
  });

  // Add IPC listener for collapse-pastille
  ipcMain.on('collapse-pastille', () => {
    if (pastilleWindow) {
      pastilleWindow.setSize(500, 70, true);
      pastilleWindow.setAlwaysOnTop(false);
    }
  });

  // Add IPC listener for clipboard navigation from control bar
  ipcMain.on('clipboard-navigate', (event, direction) => {
    console.log('üîÑ Received clipboard-navigate event:', direction);
    if (direction === 'next') {
      handleClipboardNext();
    } else if (direction === 'previous') {
      handleClipboardPrevious();
    }
  });

  // Add IPC listener for opening settings
  ipcMain.on('open-settings', () => {
    console.log('‚öôÔ∏è Opening settings window...');
    openSettingsWindow();
  });

  // Add IPC listener for opening spell book
  ipcMain.on('open-spell-book', () => {
    console.log('üßô‚Äç‚ôÇÔ∏è Opening spell book window...');
    openSpellBookWindow();
  });

  // Add IPC listeners for settings management
  ipcMain.on('load-settings', (event) => {
    console.log('üìã Loading settings for dashboard...');
    const settings = {
      OPENAI_API_KEY: config.OPENAI_API_KEY || '',
      WHISPER_MODEL: config.WHISPER_MODEL,
      TTS_VOICE: config.TTS_VOICE,
      MICROPHONE_DEVICE: audioManager?.getMicrophoneDevice() || 'auto'
    };
    event.reply('settings-loaded', settings);
  });

  ipcMain.on('save-settings', (event, newSettings) => {
    console.log('üíæ Saving settings from dashboard...');
    try {
      // Update config object (note: this only updates runtime, not persistent storage)
      config.OPENAI_API_KEY = newSettings.OPENAI_API_KEY;
      config.WHISPER_MODEL = newSettings.WHISPER_MODEL;
      config.TTS_VOICE = newSettings.TTS_VOICE;
      
      // Update microphone device if provided
      if (newSettings.MICROPHONE_DEVICE !== undefined && audioManager) {
        audioManager.setMicrophoneDevice(newSettings.MICROPHONE_DEVICE);
      }
      
      console.log('‚úÖ Settings updated successfully');
      event.reply('settings-saved', true, 'Settings saved successfully!');
    } catch (error) {
      console.error('‚ùå Error saving settings:', error);
      event.reply('settings-saved', false, 'Failed to save settings: ' + (error as Error).message);
    }
  });

  ipcMain.on('validate-api-key', async (event, apiKey) => {
    console.log('üîç Validating API key...');
    try {
      // Simple validation - try to make a basic API call with timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000);
      
      const response = await fetch('https://api.openai.com/v1/models', {
        headers: {
          'Authorization': `Bearer ${apiKey}`,
        },
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);
      const isValid = response.ok;
      console.log('üîë API key validation result:', isValid);
      event.reply('api-key-validated', isValid);
    } catch (error) {
      console.log('‚ùå API key validation failed:', error.message);
      event.reply('api-key-validated', false);
    }
  });

  // Voice testing handler is now in setupEssentialIpcHandlers()

  // Recording system is now handled by AudioManager

  // Environment variable handlers are now in setupEssentialIpcHandlers()

  // Microphone device handling is now managed by AudioManager

  // Python Setup IPC Handlers
  ipcMain.on('check-python-setup', async (event) => {
    try {
      const setupManager = PythonSetupManager.getInstance();
      const status = await setupManager.checkSetupStatus();
      event.reply('python-setup-status', status);
    } catch (error) {
      console.error('Failed to check Python setup status:', error);
      event.reply('python-setup-status', { isConfigured: false, error: (error as Error).message });
    }
  });

  ipcMain.handle('check-python-setup', async () => {
    try {
      const setupManager = PythonSetupManager.getInstance();
      const status = await setupManager.checkSetupStatus();
      return status;
    } catch (error) {
      console.error('Failed to check Python setup status:', error);
      return { isConfigured: false, error: (error as Error).message };
    }
  });

      ipcMain.handle('setup-python-auto', async () => {
      try {
        const setupManager = PythonSetupManager.getInstance();
        const success = await setupManager.performAutoSetup();
        
        if (success) {
          // Restart the Python daemon after successful setup to ensure it gets the model configuration
          console.log('üöÄ Restarting Python daemon after successful auto setup...');
          try {
            // Check if daemon is already running and restart it, or start it fresh
            const daemon = await PythonDaemon.getInstance();
            if (daemon.isRunning()) {
              await daemon.stop();
              await daemon.start();
            } else {
              await daemon.start();
            }
            console.log('‚úÖ Python daemon started successfully after auto setup');
          } catch (daemonError) {
            console.error('‚ö†Ô∏è Python daemon failed to start after auto setup:', daemonError);
            // Don't fail the setup because of daemon startup issues
          }
        }
        
        return { success };
      } catch (error) {
        console.error('Auto Python setup failed:', error);
        return { success: false, error: (error as Error).message };
      }
    });

    ipcMain.handle('setup-python-custom', async () => {
      try {
        const setupManager = PythonSetupManager.getInstance();
        const success = await setupManager.promptForCustomPython();
        
        if (success) {
          // Restart the Python daemon after successful setup to ensure it gets the model configuration
          console.log('üöÄ Restarting Python daemon after successful custom setup...');
          try {
            // Check if daemon is already running and restart it, or start it fresh
            const daemon = await PythonDaemon.getInstance();
            if (daemon.isRunning()) {
              await daemon.stop();
              await daemon.start();
            } else {
              await daemon.start();
            }
            console.log('‚úÖ Python daemon started successfully after custom setup');
          } catch (daemonError) {
            console.error('‚ö†Ô∏è Python daemon failed to start after custom setup:', daemonError);
            // Don't fail the setup because of daemon startup issues
          }
        }
        
        return { success };
      } catch (error) {
        console.error('Custom Python setup failed:', error);
        return { success: false, error: (error as Error).message };
      }
    });

  ipcMain.handle('reset-python-setup', async () => {
    try {
      const setupManager = PythonSetupManager.getInstance();
      const success = await setupManager.resetSetup();
      return { success };
    } catch (error) {
      console.error('Python setup reset failed:', error);
      return { success: false, error: (error as Error).message };
    }
  });

  // Python dependency checking
  ipcMain.handle('check-python-dependencies', async (event, pythonPath: string) => {
    try {
      const setupManager = PythonSetupManager.getInstance();
      const dependencies = await (setupManager as any).checkPythonDependencies(pythonPath);
      return dependencies;
    } catch (error) {
      console.error('Failed to check Python dependencies:', error);
      throw error;
    }
  });

  // Python dependency installation
  ipcMain.handle('install-python-dependencies', async (event, pythonPath: string) => {
    try {
      const setupManager = PythonSetupManager.getInstance();
      const result = await (setupManager as any).installPythonDependencies(pythonPath);
      return result;
    } catch (error) {
      console.error('Failed to install Python dependencies:', error);
      return { success: false, error: (error as Error).message };
    }
  });

  // Python discovery (for progress indication)
  ipcMain.handle('discover-python-installations', async () => {
    try {
      const setupManager = PythonSetupManager.getInstance();
      const pythons = await (setupManager as any).discoverPythonInstallations();
      return pythons;
    } catch (error) {
      console.error('Failed to discover Python installations:', error);
      return [];
    }
  });

  // Main Window IPC Handlers
  ipcMain.on('main-window-ready', () => {
    console.log('ü™ü Main window ready');
  });

  ipcMain.on('minimize-main-window', () => {
    if (mainWindow) {
      mainWindow.minimize();
    }
  });

  ipcMain.on('close-main-window', () => {
    if (mainWindow) {
      mainWindow.close();
    }
  });

  ipcMain.on('hide-to-tray', () => {
    if (mainWindow) {
      mainWindow.hide();
      showPillNotification('MetaKeyAI hidden to tray');
    }
  });

  ipcMain.handle('get-app-version', () => {
    return app.getVersion();
  });

  ipcMain.handle('get-settings', () => {
    return {
      OPENAI_API_KEY: config.OPENAI_API_KEY || '',
      WHISPER_MODEL: config.WHISPER_MODEL,
      TTS_VOICE: config.TTS_VOICE,
      MICROPHONE_DEVICE: audioManager?.getMicrophoneDevice() || 'auto'
    };
  });

  // Feature trigger handlers
  ipcMain.on('trigger-voice-record', () => {
    handleVoiceRecord();
  });

  ipcMain.on('trigger-text-to-speech', () => {
    handleTextToSpeech();
  });

  ipcMain.on('trigger-quick-edit', () => {
    handleQuickEdit();
  });

  ipcMain.on('trigger-clipboard-history', () => {
    handleShowClipboard();
  });

  // UserDataManager access handlers are now in setupEssentialIpcHandlers()
}
